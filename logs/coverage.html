
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maynagashev/go-metrics/cmd/agent/config_json.go (88.6%)</option>
				
				<option value="file1">github.com/maynagashev/go-metrics/cmd/agent/flags.go (79.3%)</option>
				
				<option value="file2">github.com/maynagashev/go-metrics/cmd/agent/main.go (81.8%)</option>
				
				<option value="file3">github.com/maynagashev/go-metrics/cmd/agent/pprof.go (100.0%)</option>
				
				<option value="file4">github.com/maynagashev/go-metrics/cmd/keygen/main.go (81.2%)</option>
				
				<option value="file5">github.com/maynagashev/go-metrics/cmd/migrate/main.go (76.9%)</option>
				
				<option value="file6">github.com/maynagashev/go-metrics/cmd/server/main.go (20.8%)</option>
				
				<option value="file7">github.com/maynagashev/go-metrics/cmd/staticlint/passes/errcheck/analyzer.go (81.9%)</option>
				
				<option value="file8">github.com/maynagashev/go-metrics/cmd/staticlint/passes/noexit/analyzer.go (85.4%)</option>
				
				<option value="file9">github.com/maynagashev/go-metrics/cmd/staticlint/staticlint.go (59.6%)</option>
				
				<option value="file10">github.com/maynagashev/go-metrics/example/setup.go (80.0%)</option>
				
				<option value="file11">github.com/maynagashev/go-metrics/internal/agent/agent.go (73.4%)</option>
				
				<option value="file12">github.com/maynagashev/go-metrics/internal/agent/client/factory.go (91.7%)</option>
				
				<option value="file13">github.com/maynagashev/go-metrics/internal/agent/grpc/client.go (6.0%)</option>
				
				<option value="file14">github.com/maynagashev/go-metrics/internal/agent/http/client.go (59.0%)</option>
				
				<option value="file15">github.com/maynagashev/go-metrics/internal/agent/ip.go (57.1%)</option>
				
				<option value="file16">github.com/maynagashev/go-metrics/internal/contracts/metrics/metrics.go (90.0%)</option>
				
				<option value="file17">github.com/maynagashev/go-metrics/internal/grpc/pb/metrics.pb.go (4.9%)</option>
				
				<option value="file18">github.com/maynagashev/go-metrics/internal/grpc/pb/metrics_grpc.pb.go (0.0%)</option>
				
				<option value="file19">github.com/maynagashev/go-metrics/internal/server/app/app.go (8.7%)</option>
				
				<option value="file20">github.com/maynagashev/go-metrics/internal/server/app/config.go (57.9%)</option>
				
				<option value="file21">github.com/maynagashev/go-metrics/internal/server/app/config_json.go (89.8%)</option>
				
				<option value="file22">github.com/maynagashev/go-metrics/internal/server/app/flags.go (58.0%)</option>
				
				<option value="file23">github.com/maynagashev/go-metrics/internal/server/grpc/metrics_service.go (0.0%)</option>
				
				<option value="file24">github.com/maynagashev/go-metrics/internal/server/grpc/server.go (0.0%)</option>
				
				<option value="file25">github.com/maynagashev/go-metrics/internal/server/grpc/wrapper.go (0.0%)</option>
				
				<option value="file26">github.com/maynagashev/go-metrics/internal/server/handlers/json/index/index.go (63.6%)</option>
				
				<option value="file27">github.com/maynagashev/go-metrics/internal/server/handlers/json/ping/ping.go (91.7%)</option>
				
				<option value="file28">github.com/maynagashev/go-metrics/internal/server/handlers/json/update/json_update.go (88.9%)</option>
				
				<option value="file29">github.com/maynagashev/go-metrics/internal/server/handlers/json/updates/json_updates.go (90.9%)</option>
				
				<option value="file30">github.com/maynagashev/go-metrics/internal/server/handlers/json/value/json_value.go (83.3%)</option>
				
				<option value="file31">github.com/maynagashev/go-metrics/internal/server/handlers/plain/index/index.go (92.9%)</option>
				
				<option value="file32">github.com/maynagashev/go-metrics/internal/server/handlers/plain/update/plain_update.go (78.9%)</option>
				
				<option value="file33">github.com/maynagashev/go-metrics/internal/server/handlers/plain/value/plain_value.go (90.9%)</option>
				
				<option value="file34">github.com/maynagashev/go-metrics/internal/server/middleware/decompress/decompress.go (84.2%)</option>
				
				<option value="file35">github.com/maynagashev/go-metrics/internal/server/middleware/decompresspool/decompresspool.go (55.6%)</option>
				
				<option value="file36">github.com/maynagashev/go-metrics/internal/server/middleware/ipfilter/ipfilter.go (100.0%)</option>
				
				<option value="file37">github.com/maynagashev/go-metrics/internal/server/middleware/logger/logger.go (85.7%)</option>
				
				<option value="file38">github.com/maynagashev/go-metrics/internal/server/router/router.go (100.0%)</option>
				
				<option value="file39">github.com/maynagashev/go-metrics/internal/server/storage/memory/memory.go (76.0%)</option>
				
				<option value="file40">github.com/maynagashev/go-metrics/internal/server/storage/pgstorage/migration/migration.go (0.0%)</option>
				
				<option value="file41">github.com/maynagashev/go-metrics/internal/server/storage/pgstorage/pgstorage.go (36.2%)</option>
				
				<option value="file42">github.com/maynagashev/go-metrics/internal/server/storage/storage.go (100.0%)</option>
				
				<option value="file43">github.com/maynagashev/go-metrics/mocks/Repository.go (75.0%)</option>
				
				<option value="file44">github.com/maynagashev/go-metrics/mocks/Storage.go (85.7%)</option>
				
				<option value="file45">github.com/maynagashev/go-metrics/pkg/crypto/crypto.go (63.9%)</option>
				
				<option value="file46">github.com/maynagashev/go-metrics/pkg/middleware/crypto/crypto.go (66.7%)</option>
				
				<option value="file47">github.com/maynagashev/go-metrics/pkg/middleware/gzip/compress.go (72.7%)</option>
				
				<option value="file48">github.com/maynagashev/go-metrics/pkg/random/float.go (80.0%)</option>
				
				<option value="file49">github.com/maynagashev/go-metrics/pkg/response/response.go (85.7%)</option>
				
				<option value="file50">github.com/maynagashev/go-metrics/pkg/sign/sign.go (90.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "time"
)

// ErrConfigFileNotSpecified возвращается, когда путь к файлу конфигурации не указан.
var ErrConfigFileNotSpecified = errors.New("config file path not specified")

// JSONConfig представляет структуру конфигурационного файла агента в формате JSON.
type JSONConfig struct {
        Address        string `json:"address"`         // Адрес и порт сервера
        ReportInterval string `json:"report_interval"` // Интервал отправки метрик в виде строки (например, "1s")
        PollInterval   string `json:"poll_interval"`   // Интервал сбора метрик в виде строки (например, "1s")
        CryptoKey      string `json:"crypto_key"`      // Путь к файлу с публичным ключом для шифрования
        RateLimit      int    `json:"rate_limit"`      // Максимальное количество одновременно исходящих запросов
        EnablePprof    bool   `json:"enable_pprof"`    // Включить профилирование через pprof
        PprofPort      string `json:"pprof_port"`      // Порт для pprof сервера
        RealIP         string `json:"real_ip"`         // IP-адрес для заголовка X-Real-IP
        GRPCAddress    string `json:"grpc_address"`    // Адрес и порт gRPC сервера
        GRPCEnabled    bool   `json:"grpc_enabled"`    // Флаг использования gRPC вместо HTTP
        GRPCTimeout    int    `json:"grpc_timeout"`    // Таймаут для gRPC запросов в секундах
        GRPCRetry      int    `json:"grpc_retry"`      // Количество повторных попыток при ошибке
}

// LoadJSONConfig загружает конфигурацию из JSON-файла.
// Возвращает ErrConfigFileNotSpecified, если файл не указан.
func LoadJSONConfig(filePath string) (*JSONConfig, error) <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return nil, ErrConfigFileNotSpecified
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config JSONConfig
        jsonErr := json.Unmarshal(data, &amp;config)
        if jsonErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", jsonErr)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// ApplyJSONConfig применяет настройки из JSON-конфигурации к флагам.
// Настройки из JSON имеют более низкий приоритет, чем флаги командной строки и переменные окружения.
func ApplyJSONConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        if jsonConfig == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Применяем настройки только если соответствующие флаги не были установлены
        // через командную строку или переменные окружения
        <span class="cov8" title="1">applyServerConfig(flags, jsonConfig)
        applySecurityConfig(flags, jsonConfig)
        applyPerformanceConfig(flags, jsonConfig)
        applyNetworkConfig(flags, jsonConfig)</span>
}

// applyServerConfig применяет настройки сервера из JSON-конфигурации.
func applyServerConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        // Адрес сервера
        if flags.Server.Addr == defaultAgentServerAddr &amp;&amp; jsonConfig.Address != "" </span><span class="cov8" title="1">{
                flags.Server.Addr = jsonConfig.Address
        }</span>

        // Интервал отправки метрик
        <span class="cov8" title="1">if flags.Server.ReportInterval == defaultReportInterval &amp;&amp; jsonConfig.ReportInterval != "" </span><span class="cov8" title="1">{
                duration, err := time.ParseDuration(jsonConfig.ReportInterval)
                if err == nil </span><span class="cov8" title="1">{
                        flags.Server.ReportInterval = duration.Seconds()
                }</span>
        }

        // Интервал сбора метрик
        <span class="cov8" title="1">if flags.Server.PollInterval == defaultPollInterval &amp;&amp; jsonConfig.PollInterval != "" </span><span class="cov8" title="1">{
                duration, err := time.ParseDuration(jsonConfig.PollInterval)
                if err == nil </span><span class="cov8" title="1">{
                        flags.Server.PollInterval = duration.Seconds()
                }</span>
        }
}

// applySecurityConfig применяет настройки безопасности из JSON-конфигурации.
func applySecurityConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        // Путь к файлу с публичным ключом для шифрования
        if flags.CryptoKey == "" &amp;&amp; jsonConfig.CryptoKey != "" </span><span class="cov8" title="1">{
                flags.CryptoKey = jsonConfig.CryptoKey
        }</span>
}

// applyPerformanceConfig применяет настройки производительности из JSON-конфигурации.
func applyPerformanceConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        // Максимальное количество одновременно исходящих запросов
        if flags.RateLimit == defaultRateLimit &amp;&amp; jsonConfig.RateLimit &gt; 0 </span><span class="cov8" title="1">{
                flags.RateLimit = jsonConfig.RateLimit
        }</span>

        // Включить профилирование через pprof
        <span class="cov8" title="1">if !flags.EnablePprof &amp;&amp; jsonConfig.EnablePprof </span><span class="cov8" title="1">{
                flags.EnablePprof = jsonConfig.EnablePprof
        }</span>

        // Порт для pprof сервера
        <span class="cov8" title="1">if flags.PprofPort == defaultPprofPort &amp;&amp; jsonConfig.PprofPort != "" </span><span class="cov8" title="1">{
                flags.PprofPort = jsonConfig.PprofPort
        }</span>
}

// applyNetworkConfig применяет сетевые настройки из JSON-конфигурации.
func applyNetworkConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        // IP-адрес для заголовка X-Real-IP
        if flags.RealIP == "" &amp;&amp; jsonConfig.RealIP != "" </span><span class="cov0" title="0">{
                flags.RealIP = jsonConfig.RealIP
        }</span>

        // gRPC настройки
        <span class="cov8" title="1">if flags.GRPCAddress == defaultGRPCAddress &amp;&amp; jsonConfig.GRPCAddress != "" </span><span class="cov0" title="0">{
                flags.GRPCAddress = jsonConfig.GRPCAddress
        }</span>

        <span class="cov8" title="1">if !flags.GRPCEnabled &amp;&amp; jsonConfig.GRPCEnabled </span><span class="cov0" title="0">{
                flags.GRPCEnabled = jsonConfig.GRPCEnabled
        }</span>

        <span class="cov8" title="1">if flags.GRPCTimeout == defaultGRPCTimeout &amp;&amp; jsonConfig.GRPCTimeout &gt; 0 </span><span class="cov0" title="0">{
                flags.GRPCTimeout = jsonConfig.GRPCTimeout
        }</span>

        <span class="cov8" title="1">if flags.GRPCRetry == defaultGRPCRetry &amp;&amp; jsonConfig.GRPCRetry &gt; 0 </span><span class="cov0" title="0">{
                flags.GRPCRetry = jsonConfig.GRPCRetry
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        "os"
        "strconv"
)

const (
        defaultReportInterval  = 10.0
        defaultPollInterval    = 2.0
        defaultRateLimit       = 3
        minInterval            = 0.000001 // Минимально допустимый интервал в секундах.
        defaultPprofPort       = "6060"
        defaultAgentServerAddr = "localhost:8080" // Адрес и порт сервера по умолчанию
        defaultGRPCAddress     = "localhost:9090" // Адрес и порт gRPC сервера по умолчанию
        defaultGRPCTimeout     = 5                // Таймаут для gRPC запросов в секундах по умолчанию
        defaultGRPCRetry       = 3                // Количество повторных попыток при ошибке по умолчанию
)

// Flags содержит флаги агента.
type Flags struct {
        Server struct {
                Addr           string
                ReportInterval float64
                PollInterval   float64
        }
        PrivateKey  string
        CryptoKey   string // путь к файлу с публичным ключом для шифрования
        RateLimit   int
        EnablePprof bool   // добавляем поле для профилирования
        PprofPort   string // добавляем порт для pprof
        ConfigFile  string // путь к файлу конфигурации в формате JSON
        RealIP      string // явно указанный IP-адрес для заголовка X-Real-IP
        GRPCAddress string // адрес и порт gRPC сервера
        GRPCEnabled bool   // флаг использования gRPC вместо HTTP
        GRPCTimeout int    // таймаут для gRPC запросов в секундах
        GRPCRetry   int    // количество повторных попыток при ошибке
}

// mustParseFlags обрабатывает аргументы командной строки
// и сохраняет их значения в соответствующих переменных.
func mustParseFlags() Flags <span class="cov8" title="1">{
        flags := Flags{}

        // Регистрируем флаги командной строки
        registerCommandLineFlags(&amp;flags)

        // Парсим переданные серверу аргументы в зарегистрированные переменные
        flag.Parse()

        // Применяем переменные окружения
        applyEnvironmentVariables(&amp;flags)

        // Загружаем и применяем JSON-конфигурацию
        applyJSONConfig(&amp;flags)

        // Проверяем и корректируем значения
        validateFlags(&amp;flags)

        return flags
}</span>

// registerCommandLineFlags регистрирует флаги командной строки.
func registerCommandLineFlags(flags *Flags) <span class="cov8" title="1">{
        flag.StringVar(
                &amp;flags.Server.Addr,
                "a",
                defaultAgentServerAddr,
                "address and port of the server send metrics to",
        )
        flag.Float64Var(
                &amp;flags.Server.ReportInterval,
                "r",
                defaultReportInterval,
                "report interval in seconds",
        )
        flag.Float64Var(
                &amp;flags.Server.PollInterval,
                "p",
                defaultPollInterval,
                "poll interval in seconds",
        )
        flag.StringVar(&amp;flags.PrivateKey, "k", "", "приватный ключ для подписи запросов к серверу")
        flag.StringVar(
                &amp;flags.CryptoKey,
                "crypto-key",
                "",
                "путь к файлу с публичным ключом для шифрования",
        )
        flag.IntVar(
                &amp;flags.RateLimit,
                "l",
                defaultRateLimit,
                "макс. количество одновременно исходящих запросов на сервер",
        )
        flag.BoolVar(&amp;flags.EnablePprof, "pprof", false, "enable pprof profiling")
        flag.StringVar(&amp;flags.PprofPort, "pprof-port", defaultPprofPort, "port for pprof server")

        // Добавляем флаг для явного указания IP-адреса для заголовка X-Real-IP
        flag.StringVar(&amp;flags.RealIP, "real-ip", "", "IP address to use in X-Real-IP header")

        // Добавляем флаги для gRPC
        flag.StringVar(
                &amp;flags.GRPCAddress,
                "grpc-address",
                defaultGRPCAddress,
                "адрес и порт gRPC сервера",
        )
        flag.BoolVar(&amp;flags.GRPCEnabled, "grpc-enabled", false, "использовать gRPC вместо HTTP")
        flag.IntVar(
                &amp;flags.GRPCTimeout,
                "grpc-timeout",
                defaultGRPCTimeout,
                "таймаут для gRPC запросов в секундах",
        )
        flag.IntVar(
                &amp;flags.GRPCRetry,
                "grpc-retry",
                defaultGRPCRetry,
                "количество повторных попыток при ошибке",
        )

        // Добавляем флаг для пути к файлу конфигурации
        flag.StringVar(&amp;flags.ConfigFile, "c", "", "путь к файлу конфигурации в формате JSON")
        flag.StringVar(&amp;flags.ConfigFile, "config", "", "путь к файлу конфигурации в формате JSON")
}</span>

// applyEnvironmentVariables применяет переменные окружения к флагам.
func applyEnvironmentVariables(flags *Flags) <span class="cov8" title="1">{
        applyServerEnvVariables(flags)
        applySecurityEnvVariables(flags)
        applyPerformanceEnvVariables(flags)
        applyNetworkEnvVariables(flags)

        // Если передан путь к файлу конфигурации в параметрах окружения, используем его
        if envConfigFile, ok := os.LookupEnv("CONFIG"); ok </span><span class="cov0" title="0">{
                flags.ConfigFile = envConfigFile
        }</span>
}

// applyServerEnvVariables применяет переменные окружения для настроек сервера.
func applyServerEnvVariables(flags *Flags) <span class="cov8" title="1">{
        // если переданы переменные окружения, то они перезаписывают
        // значения флагов: envServerAddr, envReportInterval, envPollInterval
        if envServerAddr := os.Getenv("ADDRESS"); envServerAddr != "" </span><span class="cov8" title="1">{
                flags.Server.Addr = envServerAddr
        }</span>
        <span class="cov8" title="1">if envReportInterval := os.Getenv("REPORT_INTERVAL"); envReportInterval != "" </span><span class="cov8" title="1">{
                i, err := strconv.ParseFloat(envReportInterval, 64)
                if err != nil </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("error parsing env REPORT_INTERVAL %s", err))</span>
                }
                <span class="cov8" title="1">flags.Server.ReportInterval = i</span>
        }
        <span class="cov8" title="1">if envPollInterval := os.Getenv("POLL_INTERVAL"); envPollInterval != "" </span><span class="cov8" title="1">{
                i, err := strconv.ParseFloat(envPollInterval, 64)
                if err != nil </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("error parsing env POLL_INTERVAL %s", err))</span>
                }
                <span class="cov8" title="1">flags.Server.PollInterval = i</span>
        }
}

// applySecurityEnvVariables применяет переменные окружения для настроек безопасности.
func applySecurityEnvVariables(flags *Flags) <span class="cov8" title="1">{
        if envPrivateKey, ok := os.LookupEnv("KEY"); ok </span><span class="cov8" title="1">{
                flags.PrivateKey = envPrivateKey
        }</span>
        <span class="cov8" title="1">if envCryptoKey, ok := os.LookupEnv("CRYPTO_KEY"); ok </span><span class="cov0" title="0">{
                flags.CryptoKey = envCryptoKey
        }</span>
}

// applyPerformanceEnvVariables применяет переменные окружения для настроек производительности.
func applyPerformanceEnvVariables(flags *Flags) <span class="cov8" title="1">{
        if envRateLimit, ok := os.LookupEnv("RATE_LIMIT"); ok </span><span class="cov8" title="1">{
                l, err := strconv.Atoi(envRateLimit)
                if err != nil </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("error parsing env RATE_LIMIT %s", err))</span>
                }
                <span class="cov8" title="1">flags.RateLimit = l</span>
        }
}

// applyNetworkEnvVariables применяет переменные окружения для сетевых настроек.
func applyNetworkEnvVariables(flags *Flags) <span class="cov8" title="1">{
        // Добавляем обработку переменной окружения для X-Real-IP
        if envRealIP, ok := os.LookupEnv("REAL_IP"); ok </span><span class="cov0" title="0">{
                flags.RealIP = envRealIP
        }</span>

        // Добавляем обработку переменных окружения для gRPC
        <span class="cov8" title="1">applyGRPCEnvVariables(flags)</span>
}

// applyGRPCEnvVariables применяет переменные окружения для настроек gRPC.
func applyGRPCEnvVariables(flags *Flags) <span class="cov8" title="1">{
        if envGRPCAddress, ok := os.LookupEnv("GRPC_ADDRESS"); ok </span><span class="cov0" title="0">{
                flags.GRPCAddress = envGRPCAddress
        }</span>

        <span class="cov8" title="1">if envGRPCEnabled, ok := os.LookupEnv("GRPC_ENABLED"); ok </span><span class="cov0" title="0">{
                enabled, err := strconv.ParseBool(envGRPCEnabled)
                if err == nil </span><span class="cov0" title="0">{
                        flags.GRPCEnabled = enabled
                }</span>
        }

        <span class="cov8" title="1">if envGRPCTimeout, ok := os.LookupEnv("GRPC_TIMEOUT"); ok </span><span class="cov0" title="0">{
                timeout, err := strconv.Atoi(envGRPCTimeout)
                if err == nil </span><span class="cov0" title="0">{
                        flags.GRPCTimeout = timeout
                }</span>
        }

        <span class="cov8" title="1">if envGRPCRetry, ok := os.LookupEnv("GRPC_RETRY"); ok </span><span class="cov0" title="0">{
                retry, err := strconv.Atoi(envGRPCRetry)
                if err == nil </span><span class="cov0" title="0">{
                        flags.GRPCRetry = retry
                }</span>
        }
}

// applyJSONConfig загружает и применяет JSON-конфигурацию.
func applyJSONConfig(flags *Flags) <span class="cov8" title="1">{
        // Загружаем конфигурацию из JSON-файла, если он указан
        jsonConfig, configErr := LoadJSONConfig(flags.ConfigFile)
        if configErr != nil </span><span class="cov8" title="1">{
                // Если файл конфигурации не указан, это не ошибка
                if errors.Is(configErr, ErrConfigFileNotSpecified) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov0" title="0">panic(fmt.Sprintf("error loading config file: %s", configErr))</span>
        }

        // Применяем настройки из JSON-конфигурации (с более низким приоритетом)
        <span class="cov0" title="0">ApplyJSONConfig(flags, jsonConfig)</span>
}

// validateFlags проверяет и корректирует значения флагов.
func validateFlags(flags *Flags) <span class="cov8" title="1">{
        if flags.RateLimit &lt; 1 </span><span class="cov8" title="1">{
                panic("RateLimit should be greater than 0")</span>
        }

        // Устанавливаем минимальные допустимые значения для интервалов
        <span class="cov8" title="1">if flags.Server.ReportInterval &lt; minInterval </span><span class="cov8" title="1">{
                flags.Server.ReportInterval = minInterval
        }</span>
        <span class="cov8" title="1">if flags.Server.PollInterval &lt; minInterval </span><span class="cov8" title="1">{
                flags.Server.PollInterval = minInterval
        }</span>

        // Валидация gRPC параметров
        <span class="cov8" title="1">if flags.GRPCTimeout &lt; 1 </span><span class="cov0" title="0">{
                flags.GRPCTimeout = defaultGRPCTimeout
        }</span>

        <span class="cov8" title="1">if flags.GRPCRetry &lt; 0 </span><span class="cov0" title="0">{
                flags.GRPCRetry = defaultGRPCRetry
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Агент (HTTP-клиент) для сбора рантайм-метрик и их последующей отправки на сервер по протоколу HTTP
package main

import (
        "context"
        "crypto/rsa"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/maynagashev/go-metrics/internal/agent"
        "github.com/maynagashev/go-metrics/pkg/crypto"
)

// Глобальные переменные для информации о сборке.
//
//nolint:gochecknoglobals // Эти переменные необходимы для информации о версии и задаются при сборке
var (
        BuildVersion = "N/A"
        BuildDate    = "N/A"
        BuildCommit  = "N/A"
)

// printVersion выводит информацию о версии сборки.
//
//nolint:forbidigo // Используем fmt.Println для вывода в stdout согласно требованиям задания
func printVersion() <span class="cov8" title="1">{
        fmt.Println("Build version:", BuildVersion)
        fmt.Println("Build date:", BuildDate)
        fmt.Println("Build commit:", BuildCommit)
}</span>

func main() <span class="cov8" title="1">{
        initLogger()
        printVersion()

        flags := mustParseFlags()
        slog.Debug("parsed flags and env variables", "flags", flags)

        initPprof(flags)

        // Загружаем публичный ключ для шифрования, если он указан
        var publicKey *rsa.PublicKey
        if flags.CryptoKey != "" </span><span class="cov0" title="0">{
                var err error
                publicKey, err = crypto.LoadPublicKey(flags.CryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("failed to load public key", "error", err, "path", flags.CryptoKey)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">slog.Info("loaded public key for encryption", "path", flags.CryptoKey)</span>
        }

        <span class="cov8" title="1">serverURL := "http://" + flags.Server.Addr
        pollInterval := time.Duration(flags.Server.PollInterval * float64(time.Second))
        reportInterval := time.Duration(flags.Server.ReportInterval * float64(time.Second))

        // Создаем контекст с отменой для graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Канал для получения сигналов от ОС
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        // Запускаем агента
        a := agent.New(
                serverURL,
                pollInterval,
                reportInterval,
                flags.PrivateKey,
                flags.RateLimit,
                publicKey,
                flags.RealIP,
                flags.GRPCEnabled,
                flags.GRPCAddress,
                flags.GRPCTimeout,
                flags.GRPCRetry,
        )

        // Запускаем горутину для обработки сигналов
        go func() </span><span class="cov8" title="1">{
                sig := &lt;-sigCh
                slog.Info("received signal", "signal", sig)
                cancel() // Отменяем контекст, что приведет к graceful shutdown
        }</span>()

        // Запускаем агента с контекстом
        <span class="cov8" title="1">a.Run(ctx)</span>
}

func initLogger() <span class="cov8" title="1">{
        // Создаем переменную для уровня логирования и устанавливаем ее в Debug
        logLevel := new(slog.LevelVar)
        logLevel.Set(slog.LevelDebug)

        // Создаем новый обработчик с настроенным уровнем логирования
        logger := slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
                Level: logLevel,
        }))

        // Устанавливаем созданный логгер как логгер по умолчанию
        slog.SetDefault(logger)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "log/slog"
        "net/http"

        //nolint:gosec // G108: pprof is used intentionally for debugging and profiling
        _ "net/http/pprof"

        "github.com/maynagashev/go-metrics/internal/config"
)

// initPprof запускает pprof сервер если включено профилирование.
func initPprof(flags Flags) <span class="cov8" title="1">{
        if flags.EnablePprof </span><span class="cov8" title="1">{
                pprofAddr := fmt.Sprintf("localhost:%s", flags.PprofPort)
                startPProf(pprofAddr)
        }</span>
}

func startPProf(pprofAddr string) <span class="cov8" title="1">{
        if pprofAddr != "" </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        srv := &amp;http.Server{
                                Addr:              pprofAddr,
                                Handler:           nil, // использует DefaultServeMux
                                ReadTimeout:       config.DefaultReadTimeout,
                                WriteTimeout:      config.DefaultWriteTimeout,
                                ReadHeaderTimeout: config.DefaultHeaderTimeout,
                                IdleTimeout:       config.DefaultIdleTimeout,
                        }
                        if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov8" title="1">{
                                slog.Error("Failed to start pprof server", "error", err)
                        }</span>
                }()
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package main предоставляет инструмент командной строки для генерации пар ключей RSA.
package main

import (
        "flag"
        "fmt"
        "log/slog"
        "os"

        "github.com/maynagashev/go-metrics/pkg/crypto"
)

// Build information set during compilation
// These are allowed to be global variables as they are set at build time
//
//nolint:gochecknoglobals // These variables are set at build time by the compiler
var (
        // BuildVersion contains the version of the build.
        BuildVersion string
        // BuildDate contains the date of the build.
        BuildDate string
        // BuildCommit contains the commit hash of the build.
        BuildCommit string
        // ExitFunc is the function used to exit the program, can be replaced in tests.
        ExitFunc = os.Exit
)

// DefaultKeySize - размер ключа RSA по умолчанию.
const DefaultKeySize = 2048

func main() <span class="cov8" title="1">{
        // Выводим информацию о сборке
        printVersion()

        // Инициализируем логгер
        initLogger()

        // Парсим аргументы командной строки
        privateKeyPath, publicKeyPath, keySize, err := parseFlags()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Ошибка при разборе аргументов: %v\n", err)
                ExitFunc(1)
                return
        }</span>

        // Генерируем ключи
        <span class="cov8" title="1">genErr := generateKeys(privateKeyPath, publicKeyPath, keySize)
        if genErr != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Ошибка при генерации пары ключей: %v\n", genErr)
                ExitFunc(1)
                return
        }</span>

        <span class="cov8" title="1">slog.Info("Пара ключей успешно сгенерирована",
                "private_key", privateKeyPath,
                "public_key", publicKeyPath)

        slog.Warn("ВАЖНО: Храните ваш закрытый ключ в безопасном месте и не передавайте его никому!")</span>
}

// printVersion выводит информацию о версии сборки.
func printVersion() <span class="cov8" title="1">{
        slog.Info("Build information",
                "version", getStringOrDefault(BuildVersion, "N/A"),
                "date", getStringOrDefault(BuildDate, "N/A"),
                "commit", getStringOrDefault(BuildCommit, "N/A"))
}</span>

// getStringOrDefault возвращает строку или значение по умолчанию, если строка пуста.
func getStringOrDefault(value, defaultValue string) string <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov8" title="1">return value</span>
}

// parseFlags разбирает флаги командной строки.
func parseFlags() (string, string, int, error) <span class="cov8" title="1">{
        // Определяем флаги командной строки
        privateKeyPathPtr := flag.String(
                "private",
                "private.pem",
                "путь для сохранения закрытого ключа",
        )
        publicKeyPathPtr := flag.String("public", "public.pem", "путь для сохранения открытого ключа")
        keySizePtr := flag.Int("bits", DefaultKeySize, "размер ключа RSA в битах (1024, 2048, 4096)")

        // Разбираем флаги
        flag.Parse()

        // Проверяем размер ключа
        validKeySizes := map[int]bool{1024: true, 2048: true, 4096: true}
        if !validKeySizes[*keySizePtr] </span><span class="cov8" title="1">{
                return "", "", 0, fmt.Errorf(
                        "неверный размер ключа: %d. Допустимые размеры: 1024, 2048, 4096",
                        *keySizePtr,
                )
        }</span>

        <span class="cov8" title="1">return *privateKeyPathPtr, *publicKeyPathPtr, *keySizePtr, nil</span>
}

// generateKeys генерирует пару ключей RSA.
func generateKeys(privateKeyPath, publicKeyPath string, keySize int) error <span class="cov8" title="1">{
        slog.Info("Генерация RSA ключей", "bits", keySize)
        return crypto.GenerateKeyPair(privateKeyPath, publicKeyPath, keySize)
}</span>

// initLogger инициализирует логгер.
func initLogger() <span class="cov8" title="1">{
        // Создаем переменную для уровня логирования и устанавливаем ее в Info
        logLevel := new(slog.LevelVar)
        logLevel.Set(slog.LevelInfo)

        // Создаем новый обработчик с настроенным уровнем логирования
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: logLevel,
        }))

        // Устанавливаем созданный логгер как логгер по умолчанию
        slog.SetDefault(logger)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Утилита для миграции базы данных, обертка над библиотекой golang-migrate/migrate.
package main

import (
        "errors"
        "flag"

        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"

        "github.com/maynagashev/go-metrics/internal/server/storage/pgstorage/migration"
)

func run(dsn, migrationsPath string) error <span class="cov8" title="1">{
        if dsn == "" </span><span class="cov8" title="1">{
                return errors.New(
                        "не указаны параметры подключения к БД: -d postgres://user:password@localhost:5432/database",
                )
        }</span>
        <span class="cov8" title="1">if migrationsPath == "" </span><span class="cov8" title="1">{
                return errors.New(
                        "не указан путь к директории с миграциями: -migrations-path ../../migrations",
                )
        }</span>

        <span class="cov0" title="0">if err := migration.Up(migrationsPath, dsn); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func main() <span class="cov8" title="1">{
        var dsn, migrationsPath string
        flag.StringVar(
                &amp;dsn,
                "d",
                "",
                "Параметры подключения к базе данных Postgres, формат: postgres://user:password@localhost:5432/database",
        )
        flag.StringVar(&amp;migrationsPath, "migrations-path", "", "Путь к директории с миграциями")
        flag.Parse()

        if err := run(dsn, migrationsPath); err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package main реализует HTTP-сервер для сбора и хранения метрик.
//
// Сервер поддерживает хранение метрик в PostgreSQL или в памяти. Выбор хранилища
// определяется наличием параметров подключения к БД (флаг -d или переменная DATABASE_DSN).
//
// # Поддерживаемые типы метрик
//
//   - gauge - число с плавающей точкой
//   - counter - целочисленный счетчик
//
// # API Endpoints
//
//   - POST /update - обновление одиночной метрики
//   - POST /updates/ - пакетное обновление метрик
//   - POST /value - получение значения метрики
//   - GET /ping - проверка подключения к БД
//   - GET / - получение всех метрик (текстовый формат)
//
// # gRPC API
//
// Сервер также поддерживает gRPC-интерфейс для работы с метриками:
//   - Update - обновление одиночной метрики
//   - UpdateBatch - пакетное обновление метрик
//   - GetValue - получение значения метрики
//   - Ping - проверка подключения к БД
//   - StreamMetrics - потоковая отправка метрик
//
// # Конфигурация
//
// Сервер поддерживает настройку через флаги командной строки и переменные окружения:
//   - DATABASE_DSN - строка подключения к PostgreSQL
//   - STORE_INTERVAL - интервал сохранения метрик (для in-memory хранилища)
//   - FILE_STORAGE_PATH - путь к файлу для сохранения метрик
//   - RESTORE - восстанавливать ли метрики из файла при старте
//   - GRPC_ENABLED - включить gRPC сервер
//   - GRPC_ADDRESS - адрес для gRPC сервера
//
// # Примеры
//
// Примеры использования API представлены в тестах:
//   - Example - обновление метрики
//   - Example_getValue - получение значения
//   - Example_updateBatch - пакетное обновление
//   - Example_ping - проверка БД
package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        //nolint:gosec // G108: pprof is used intentionally for debugging and profiling
        _ "net/http/pprof"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/server/app"
        grpcserver "github.com/maynagashev/go-metrics/internal/server/grpc"
        "github.com/maynagashev/go-metrics/internal/server/router"
        "github.com/maynagashev/go-metrics/internal/server/storage"
        "github.com/maynagashev/go-metrics/internal/server/storage/memory"
        "github.com/maynagashev/go-metrics/internal/server/storage/pgstorage"
)

// Глобальные переменные для информации о сборке.
//
//nolint:gochecknoglobals // Эти переменные необходимы для информации о версии и задаются при сборке
var (
        BuildVersion = "N/A"
        BuildDate    = "N/A"
        BuildCommit  = "N/A"
)

// printVersion выводит информацию о версии сборки.
//
//nolint:forbidigo // Используем fmt.Println для вывода в stdout согласно требованиям задания
func printVersion() <span class="cov8" title="1">{
        fmt.Println("Build version:", BuildVersion)
        fmt.Println("Build date:", BuildDate)
        fmt.Println("Build commit:", BuildCommit)
}</span>

func main() <span class="cov0" title="0">{
        log := initLogger()
        defer func() </span><span class="cov0" title="0">{
                // Ignore stderr sync error as it's harmless
                if syncErr := log.Sync(); syncErr != nil &amp;&amp;
                        syncErr.Error() != "sync /dev/stderr: invalid argument" </span><span class="cov0" title="0">{
                        log.Error("failed to sync logger", zap.Error(syncErr))
                }</span>
        }()

        <span class="cov0" title="0">printVersion()

        flags, err := app.ParseFlags()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">cfg := app.NewConfig(flags)
        server := app.New(cfg)

        // Инициализируем хранилище
        repo, storageErr := initStorage(cfg, log)
        if storageErr != nil </span><span class="cov0" title="0">{
                log.Error("failed to init storage", zap.Error(storageErr))
                panic(storageErr)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                closeErr := repo.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        log.Error("failed to close storage", zap.Error(closeErr))
                }</span>
        }()

        // Создаем контекст для graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Инициализируем gRPC сервер
        grpcSrv := grpcserver.NewServer(log, cfg, repo)
        startErr := grpcSrv.Start(ctx)
        if startErr != nil </span><span class="cov0" title="0">{
                log.Error("failed to start gRPC server", zap.Error(startErr))
                panic(startErr)</span>
        }

        // Инициализируем HTTP router
        <span class="cov0" title="0">handlers := router.New(cfg, repo, log)

        // Запускаем HTTP сервер
        go server.Start(log, handlers)

        // Канал для получения сигналов от ОС
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        // Ожидаем сигнал для graceful shutdown
        sig := &lt;-sigCh
        log.Info("received signal, initiating graceful shutdown", zap.String("signal", sig.String()))

        // Отменяем контекст, что приведет к graceful shutdown gRPC сервера
        cancel()

        log.Debug("server stopped")</span>
}

func initStorage(cfg *app.Config, log *zap.Logger) (storage.Repository, error) <span class="cov8" title="1">{
        // Если указан DATABASE_DSN или флаг -d, то используем PostgreSQL.
        if cfg.IsDatabaseEnabled() </span><span class="cov0" title="0">{
                pg, err := pgstorage.New(context.Background(), cfg, log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return pg, nil</span>
        }

        <span class="cov8" title="1">return memory.New(cfg, log), nil</span>
}

func initLogger() *zap.Logger <span class="cov8" title="1">{
        // Создаем конфигурацию для регистратора в режиме разработки
        cfg := zap.NewDevelopmentConfig()

        // Указываем путь к файлу для записи логов, для записи в файл добавить в список например: "../../run.log"
        cfg.OutputPaths = []string{"stderr"}

        // Создаем регистратор с заданной конфигурацией
        logger, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                // вызываем панику, если ошибка
                panic(err)</span>
        }
        <span class="cov8" title="1">return logger</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package errcheck реализует анализатор для проверки необработанных ошибок в Go-коде.
// Анализатор обнаруживает случаи, когда возвращаемая функцией ошибка игнорируется
// или явно отбрасывается путем присваивания её "_".
//
// # Обзор
//
// Обработка ошибок является критически важной частью написания надежного Go-кода.
// Этот анализатор помогает убедиться, что ошибки, возвращаемые функциями,
// правильно проверяются и обрабатываются.
//
// Анализатор обнаруживает два основных паттерна:
//   - Вызов функции, которая возвращает ошибку, без использования результата
//   - Явное отбрасывание ошибки путем присваивания её "_"
//
// # Использование
//
// Чтобы использовать этот анализатор, включите его в ваш мультичекер:
//
//        mychecks := []*analysis.Analyzer{
//                errcheck.Analyzer,
//                // другие анализаторы...
//        }
//        multichecker.Main(mychecks...)
//
// # Пример
//
// Следующий код вызовет предупреждения:
//
//        func example() {
//                // Ошибка не проверяется
//                os.Remove("file.txt")
//
//                // Ошибка явно отбрасывается
//                _, _ = os.Open("file.txt")
//        }
//
// Лучшим подходом будет правильная обработка ошибок:
//
//        func example() error {
//                err := os.Remove("file.txt")
//                if err != nil {
//                        return fmt.Errorf("failed to remove file: %w", err)
//                }
//
//                file, err := os.Open("file.txt")
//                if err != nil {
//                        return fmt.Errorf("failed to open file: %w", err)
//                }
//                defer file.Close()
//                return nil
//        }
package errcheck

import (
        "go/ast"
        "go/types"
        "strings"

        "golang.org/x/tools/go/analysis"
)

// getErrorType возвращает интерфейс типа error.
// Функция получает тип error из universe scope и возвращает его как интерфейс.
// Паникует, если тип error не найден или имеет неожиданный тип.
func getErrorType() *types.Interface <span class="cov8" title="1">{
        err := types.Universe.Lookup("error")
        if err == nil </span><span class="cov0" title="0">{
                panic("error type not found in universe")</span>
        }
        <span class="cov8" title="1">typ := err.Type()
        if typ == nil </span><span class="cov0" title="0">{
                panic("error type is nil")</span>
        }
        <span class="cov8" title="1">underlying := typ.Underlying()
        if underlying == nil </span><span class="cov0" title="0">{
                panic("error underlying type is nil")</span>
        }
        <span class="cov8" title="1">iface, ok := underlying.(*types.Interface)
        if !ok </span><span class="cov0" title="0">{
                panic("error type is not an interface")</span>
        }
        <span class="cov8" title="1">return iface</span>
}

// NewAnalyzer создает новый анализатор для проверки обработки ошибок.
// Возвращает настроенный анализатор, готовый к использованию.
func NewAnalyzer() *analysis.Analyzer <span class="cov8" title="1">{
        return &amp;analysis.Analyzer{
                Name: "errcheck",
                Doc:  "check for unchecked errors",
                Run:  run,
        }
}</span>

// Analyzer - анализатор для проверки необработанных ошибок.
// Он обнаруживает случаи, когда возвращаемая функцией ошибка игнорируется или явно отбрасывается.
//
//nolint:gochecknoglobals // Analyzer должен быть глобальной переменной для доступа из других пакетов
var Analyzer = NewAnalyzer()

func isErrorType(t types.Type) bool <span class="cov8" title="1">{
        return types.Implements(t, getErrorType())
}</span>

// analysisResult содержит результаты анализа.
// Он отслеживает, были ли найдены проблемы, и хранит ссылку на проход анализа.
type analysisResult struct {
        hasIssues bool
        pass      *analysis.Pass
}

// getIgnoredFunctions возвращает карту имен функций, ошибки которых можно игнорировать.
// Это карта для эффективного поиска, с именами функций в качестве ключей.
func getIgnoredFunctions() map[string]bool <span class="cov8" title="1">{
        return map[string]bool{
                "fmt.Print":   true,
                "fmt.Printf":  true,
                "fmt.Println": true,
        }
}</span>

// shouldIgnoreCall проверяет, следует ли игнорировать ошибки от данного вызова.
// Возвращает true, если вызов функции находится в списке игнорируемых функций.
//
// Параметры:
//   - pass: проход анализа
//   - call: выражение вызова для проверки
func shouldIgnoreCall(_ *analysis.Pass, call *ast.CallExpr) bool <span class="cov8" title="1">{
        fun, ok := call.Fun.(*ast.SelectorExpr)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">pkgName, ok := fun.X.(*ast.Ident)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        // Получаем полное имя функции в формате "пакет.функция"
        <span class="cov8" title="1">fullName := pkgName.Name + "." + fun.Sel.Name

        // Проверяем, есть ли функция в списке игнорируемых
        ignoredFunctions := getIgnoredFunctions()
        for prefix := range ignoredFunctions </span><span class="cov8" title="1">{
                if strings.HasPrefix(fullName, prefix) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// processExprStmt проверяет выражения на необработанные ошибки.
// Сообщает о проблеме, если выражение возвращает ошибку, которая не проверяется.
//
// Параметры:
//   - x: выражение для проверки
func (r *analysisResult) processExprStmt(x *ast.ExprStmt) <span class="cov8" title="1">{
        call, ok := x.X.(*ast.CallExpr)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if isReturnError(r.pass, call) &amp;&amp; !shouldIgnoreCall(r.pass, call) </span><span class="cov8" title="1">{
                r.hasIssues = true
                r.pass.Reportf(x.Pos(), "expression returns unchecked error")
        }</span>
}

// processTupleAssign проверяет присваивания кортежей на необработанные ошибки.
// Сообщает о проблеме, если ошибка явно отбрасывается путем присваивания "_".
//
// Параметры:
//   - x: выражение присваивания для проверки
func (r *analysisResult) processTupleAssign(x *ast.AssignStmt) <span class="cov8" title="1">{
        call, ok := x.Rhs[0].(*ast.CallExpr)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if shouldIgnoreCall(r.pass, call) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">results := resultErrors(r.pass, call)
        for i := range x.Lhs </span><span class="cov8" title="1">{
                if id, isIdent := x.Lhs[i].(*ast.Ident); isIdent &amp;&amp; id.Name == "_" &amp;&amp; results[i] </span><span class="cov8" title="1">{
                        r.hasIssues = true
                        r.pass.Reportf(id.NamePos, "assignment with unchecked error")
                }</span>
        }
}

// processMultiAssign проверяет множественные присваивания на необработанные ошибки.
// Сообщает о проблеме, если ошибка явно отбрасывается путем присваивания "_".
//
// Параметры:
//   - x: выражение присваивания для проверки
func (r *analysisResult) processMultiAssign(x *ast.AssignStmt) <span class="cov8" title="1">{
        for i := range x.Lhs </span><span class="cov8" title="1">{
                id, isIdent := x.Lhs[i].(*ast.Ident)
                if !isIdent </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">call, isCall := x.Rhs[i].(*ast.CallExpr)
                if !isCall </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if shouldIgnoreCall(r.pass, call) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if id.Name == "_" &amp;&amp; isReturnError(r.pass, call) </span><span class="cov0" title="0">{
                        r.hasIssues = true
                        r.pass.Reportf(id.NamePos, "assignment with unchecked error")
                }</span>
        }
}

// processNode обрабатывает один узел AST.
// Он направляет обработку в соответствующий обработчик в зависимости от типа узла.
//
// Параметры:
//   - node: узел AST для обработки
//
// Возвращает true для продолжения обхода AST.
func (r *analysisResult) processNode(node ast.Node) bool <span class="cov8" title="1">{
        switch x := node.(type) </span>{
        case *ast.ExprStmt:<span class="cov8" title="1">
                r.processExprStmt(x)</span>
        case *ast.AssignStmt:<span class="cov8" title="1">
                if len(x.Rhs) == 1 </span><span class="cov8" title="1">{
                        r.processTupleAssign(x)
                }</span> else<span class="cov8" title="1"> {
                        r.processMultiAssign(x)
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// run реализует логику анализа для анализатора errcheck.
// Он обходит AST каждого файла в пакете и проверяет наличие необработанных ошибок.
//
// Параметры:
//   - pass: проход анализа, содержащий AST и информацию о типах
//
// Возвращает nil, nil, если проблемы не найдены (стандартное поведение для анализаторов).
func run(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        result := &amp;analysisResult{
                pass: pass,
        }

        // Проходим по всем файлам в пакете
        for _, file := range pass.Files </span><span class="cov8" title="1">{
                // Проходим по всем узлам в файле
                ast.Inspect(file, result.processNode)
        }</span>

        //nolint:nilnil // Стандартное поведение для анализаторов - возвращать nil, nil если проблем не найдено
        <span class="cov8" title="1">return nil, nil</span>
}

// resultErrors определяет, какие из возвращаемых значений функции являются ошибками.
// Возвращает массив булевых значений, где true означает, что соответствующее
// возвращаемое значение имеет тип error.
//
// Параметры:
//   - pass: проход анализа, содержащий информацию о типах
//   - call: выражение вызова для проверки
func resultErrors(pass *analysis.Pass, call *ast.CallExpr) []bool <span class="cov8" title="1">{
        // Получаем тип выражения вызова
        callType := pass.TypesInfo.Types[call].Type
        if callType == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Получаем тип функции
        <span class="cov8" title="1">switch t := callType.(type) </span>{
        case *types.Tuple:<span class="cov8" title="1">
                // Функция возвращает несколько значений
                n := t.Len()
                res := make([]bool, n)
                for i := range n </span><span class="cov8" title="1">{
                        res[i] = isErrorType(t.At(i).Type())
                }</span>
                <span class="cov8" title="1">return res</span>
        default:<span class="cov8" title="1">
                // Функция возвращает одно значение
                return []bool{isErrorType(callType)}</span>
        }
}

// isReturnError проверяет, возвращает ли вызов функции ошибку.
// Возвращает true, если хотя бы одно из возвращаемых значений имеет тип error.
//
// Параметры:
//   - pass: проход анализа, содержащий информацию о типах
//   - call: выражение вызова для проверки
func isReturnError(pass *analysis.Pass, call *ast.CallExpr) bool <span class="cov8" title="1">{
        // Получаем информацию о типах возвращаемых значений
        results := resultErrors(pass, call)
        if results == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Проверяем, есть ли среди возвращаемых значений ошибка
        <span class="cov8" title="1">for _, isErr := range results </span><span class="cov8" title="1">{
                if isErr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package noexit проверяет, что в функции main пакета main нет прямых вызовов os.Exit.
//
// # Обзор
//
// Анализатор noexit обнаруживает прямые вызовы os.Exit в функции main пакета main.
// Использование os.Exit напрямую в функции main может привести к проблемам, поскольку
// это немедленно завершает программу без выполнения отложенных функций и без возможности
// корректной очистки ресурсов.
//
// # Использование
//
// Чтобы использовать этот анализатор, включите его в ваш мультичекер:
//
//        mychecks := []*analysis.Analyzer{
//                noexit.Analyzer,
//                // другие анализаторы...
//        }
//        multichecker.Main(mychecks...)
//
// # Пример
//
// Следующий код вызовет предупреждение:
//
//        package main
//
//        import (
//                "fmt"
//                "os"
//        )
//
//        func main() {
//                fmt.Println("Hello, world!")
//                os.Exit(0) // Это вызовет предупреждение
//        }
//
// Лучшим подходом будет нормальный возврат из функции main или использование
// другого механизма завершения программы, который позволяет выполнить отложенные функции.
package noexit

import (
        "errors"
        "go/ast"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

// Константы для анализатора.
const (
        mainPackageName = "main"
        mainFuncName    = "main"
)

// ErrNotMainPackage возвращается, когда анализируемый пакет не является main.
var ErrNotMainPackage = errors.New("not a main package")

// NewAnalyzer создает новый анализатор для проверки noexit.
// Он обнаруживает прямые вызовы os.Exit в функции main пакета main.
func NewAnalyzer() *analysis.Analyzer <span class="cov8" title="1">{
        return &amp;analysis.Analyzer{
                Name:     "noexit",
                Doc:      "check for direct calls to os.Exit in the main function of the main package",
                Requires: []*analysis.Analyzer{inspect.Analyzer},
                Run:      run,
        }
}</span>

// Analyzer - анализатор для проверки noexit.
// Он обнаруживает прямые вызовы os.Exit в функции main пакета main.
//
//nolint:gochecknoglobals // Analyzer должен быть глобальной переменной для доступа из других пакетов
var Analyzer = NewAnalyzer()

// 5. Сообщает об ошибке, если обнаружен прямой вызов os.Exit в main.
func run(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        // Получаем инспектор из результатов работы предыдущего анализатора
        inspectResult, ok := pass.ResultOf[inspect.Analyzer]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("inspect analyzer result not found")
        }</span>

        <span class="cov8" title="1">inspect, ok := inspectResult.(*inspector.Inspector)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("inspect analyzer result is not of type *inspector.Inspector")
        }</span>

        // Фильтр для поиска вызовов функций
        <span class="cov8" title="1">nodeFilter := []ast.Node{
                (*ast.CallExpr)(nil),
        }

        // Проверяем, что мы находимся в пакете main
        if pass.Pkg.Name() != mainPackageName </span><span class="cov0" title="0">{
                return nil, ErrNotMainPackage
        }</span>

        // Используем инспектор для поиска вызовов функций
        <span class="cov8" title="1">inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov8" title="1">{
                callExpr, isCallExpr := n.(*ast.CallExpr)
                if !isCallExpr </span><span class="cov0" title="0">{
                        return
                }</span>

                // Проверяем, что вызов находится в функции main
                <span class="cov8" title="1">if !isInMainFunc(pass, callExpr) </span><span class="cov8" title="1">{
                        return
                }</span>

                // Проверяем, что это вызов os.Exit
                <span class="cov8" title="1">if isOSExitCall(pass, callExpr) </span><span class="cov8" title="1">{
                        pass.Reportf(callExpr.Pos(), "direct call to os.Exit in main function is prohibited")
                }</span>
        })

        <span class="cov8" title="1">return nil, nil</span> //nolint:nilnil // Стандартное поведение для анализаторов - возвращать nil, nil если проблем не найдено
}

// isInMainFunc проверяет, находится ли узел внутри функции main.
// Он обходит AST для поиска содержащего функцию объявления
// и проверяет, является ли она функцией main.
//
// Параметры:
//   - pass: проход анализа, содержащий AST и информацию о типах
//   - node: узел AST для проверки
//
// Возвращает true, если узел находится внутри функции main, иначе false.
func isInMainFunc(pass *analysis.Pass, node ast.Node) bool <span class="cov8" title="1">{
        // Находим ближайшую функцию, содержащую узел
        var enclosingFunc *ast.FuncDecl
        for _, f := range pass.Files </span><span class="cov8" title="1">{
                ast.Inspect(f, func(n ast.Node) bool </span><span class="cov8" title="1">{
                        if fd, ok := n.(*ast.FuncDecl); ok </span><span class="cov8" title="1">{
                                if fd.Name.Name == "main" </span><span class="cov8" title="1">{
                                        // Проверяем, находится ли узел внутри этой функции
                                        if fd.Pos() &lt;= node.Pos() &amp;&amp; node.Pos() &lt;= fd.End() </span><span class="cov8" title="1">{
                                                enclosingFunc = fd
                                                return false
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">return true</span>
                })
                <span class="cov8" title="1">if enclosingFunc != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return enclosingFunc != nil &amp;&amp; enclosingFunc.Name.Name == "main"</span>
}

// isOSExitCall проверяет, является ли вызов функции прямым вызовом os.Exit.
// Он анализирует выражение вызова, чтобы определить, вызывается ли функция Exit
// из пакета os.
//
// Параметры:
//   - pass: проход анализа, содержащий AST и информацию о типах
//   - call: выражение вызова для проверки
//
// Возвращает true, если вызов является вызовом os.Exit, иначе false.
func isOSExitCall(pass *analysis.Pass, call *ast.CallExpr) bool <span class="cov8" title="1">{
        // Проверяем, что вызов имеет форму X.Y (например, os.Exit)
        sel, ok := call.Fun.(*ast.SelectorExpr)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        // Получаем информацию о типе X
        <span class="cov8" title="1">x, ok := sel.X.(*ast.Ident)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        // Проверяем, что X - это "os"
        <span class="cov8" title="1">obj := pass.TypesInfo.ObjectOf(x)
        if obj == nil || obj.Name() != "os" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Проверяем, что Y - это "Exit"
        <span class="cov8" title="1">return sel.Sel.Name == "Exit"</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package main утилита для статического анализа кода с заранее выбранными анализаторами.
//
// # Обзор
//
// Этот мультичекер включает:
//   - Стандартные анализаторы из пакета golang.org/x/tools/go/analysis/passes
//   - Все анализаторы класса SA из пакета staticcheck.io
//   - Выбранные анализаторы из других классов пакета staticcheck.io
//   - Собственные анализаторы (noexit, errcheck)
//   - Сторонние анализаторы (exhaustive, bodyclose)
//
// # Использование
//
// Запустите мультичекер с помощью:
//
//        go run cmd/staticlint/staticlint.go [пакеты]
//
// Или скомпилируйте и запустите:
//
//        go build -o staticlint ./cmd/staticlint
//        ./staticlint [пакеты]
//
// # Конфигурация
//
// Мультичекер можно настроить с помощью JSON-файла, расположенного по пути cmd/staticlint/config.json.
// Файл конфигурации позволяет указать, какие анализаторы из staticcheck и stylecheck использовать.
//
// Пример конфигурации:
//
//        {
//            "staticcheck": ["SA4006", "SA5000"],
//            "stylecheck": ["ST1000"]
//        }
//
// Если файл конфигурации не найден или содержит ошибки, будут использованы все доступные анализаторы.
package main

import (
        // Стандартная библиотека.
        "encoding/json"
        "log"
        "os"
        "strings"

        // Сторонние пакеты.
        "github.com/nishanths/exhaustive"
        "github.com/timakin/bodyclose/passes/bodyclose"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"

        // Локальные модули.
        "github.com/maynagashev/go-metrics/cmd/staticlint/passes/errcheck"
        "github.com/maynagashev/go-metrics/cmd/staticlint/passes/noexit"
)

// Config — имя файла конфигурации.
// Файл должен находиться в директории cmd/staticlint.
const Config = `cmd/staticlint/config.json`

// ConfigData описывает структуру файла конфигурации.
// Содержит списки анализаторов из staticcheck и stylecheck, которые нужно использовать.
type ConfigData struct {
        // Staticcheck содержит список имен анализаторов из пакета staticcheck.
        Staticcheck []string `json:"staticcheck"`
        // Stylecheck содержит список имен анализаторов из пакета stylecheck.
        Stylecheck []string `json:"stylecheck"`
}

// loadConfig загружает конфигурацию из файла.
// Возвращает конфигурацию и флаг успешности загрузки.
// Если файл не найден или содержит ошибки, возвращает пустую конфигурацию и false.
func loadConfig(path string) (ConfigData, bool) <span class="cov8" title="1">{
        var cfg ConfigData
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("Конфигурационный файл не найден")
                return cfg, false
        }</span>

        // Читаем в структуру
        <span class="cov8" title="1">if err = json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                log.Println("Ошибка при чтении конфигурационного файла:", err)
                return cfg, false
        }</span>

        <span class="cov8" title="1">return cfg, true</span>
}

// addAnalyzers добавляет анализаторы из указанного списка в mychecks.
// Функция обрабатывает анализаторы из staticcheck и stylecheck.
//
// Параметры:
//   - mychecks: текущий список анализаторов
//   - cfg: конфигурация, содержащая списки анализаторов
//   - analyzerType: тип анализаторов ("staticcheck" или "stylecheck")
//   - analyzers: полный список доступных анализаторов указанного типа
//
// Возвращает обновленный список анализаторов.
// Если в конфигурации указаны конкретные анализаторы, добавляет только их.
// Если список пуст или отсутствует, добавляет все доступные анализаторы.
func addAnalyzers(
        mychecks []*analysis.Analyzer,
        cfg ConfigData,
        analyzerType string,
        analyzers []*analysis.Analyzer,
) []*analysis.Analyzer <span class="cov8" title="1">{
        var isSet bool
        var configList []string

        // определяем существует ли секция конфигурации и список не пуст
        if analyzerType == "staticcheck" </span><span class="cov8" title="1">{
                isSet = len(cfg.Staticcheck) &gt; 0
                configList = cfg.Staticcheck
        }</span> else<span class="cov0" title="0"> if analyzerType == "stylecheck" </span><span class="cov0" title="0">{
                isSet = len(cfg.Stylecheck) &gt; 0
                configList = cfg.Stylecheck
        }</span>

        // Если секция конфигурации существует и список не пуст
        <span class="cov8" title="1">if isSet </span><span class="cov8" title="1">{
                // Создаем карту для быстрого поиска
                checks := make(map[string]bool)
                for _, name := range configList </span><span class="cov8" title="1">{
                        checks[name] = true
                }</span>

                // Добавляем только указанные анализаторы
                <span class="cov8" title="1">for _, analyzer := range analyzers </span><span class="cov0" title="0">{
                        if checks[analyzer.Name] </span><span class="cov0" title="0">{
                                mychecks = append(mychecks, analyzer)
                        }</span>
                }
                <span class="cov8" title="1">log.Printf(
                        "Используются анализаторы %s из конфигурационного файла: %v\n",
                        analyzerType,
                        configList,
                )</span>
        } else<span class="cov8" title="1"> {
                // Добавляем все анализаторы если секция не существует или пустая
                log.Printf("Используются все анализаторы %s (%s)\n", analyzerType, "секция отсутствует в конфигурации")
                mychecks = append(mychecks, analyzers...)
        }</span>

        <span class="cov8" title="1">return mychecks</span>
}

// getAllStaticcheckAnalyzers возвращает список всех анализаторов из пакета staticcheck.
// Эти анализаторы проверяют корректность кода и выявляют потенциальные ошибки.
func getAllStaticcheckAnalyzers() []*analysis.Analyzer <span class="cov8" title="1">{
        result := make([]*analysis.Analyzer, len(staticcheck.Analyzers))
        for i, a := range staticcheck.Analyzers </span><span class="cov8" title="1">{
                result[i] = a.Analyzer
        }</span>
        <span class="cov8" title="1">return result</span>
}

// getAllStylecheckAnalyzers возвращает список всех анализаторов из пакета stylecheck.
// Эти анализаторы проверяют стиль кода и соответствие стандартам оформления.
func getAllStylecheckAnalyzers() []*analysis.Analyzer <span class="cov8" title="1">{
        result := make([]*analysis.Analyzer, len(stylecheck.Analyzers))
        for i, a := range stylecheck.Analyzers </span><span class="cov8" title="1">{
                result[i] = a.Analyzer
        }</span>
        <span class="cov8" title="1">return result</span>
}

// printAnalyzersList выводит список анализаторов с их описаниями.
// Для каждого анализатора выводится его имя и краткое описание (первая строка документации).
func printAnalyzersList(analyzers []*analysis.Analyzer) <span class="cov0" title="0">{
        log.Println("Итоговый список анализаторов:")
        for i, analyzer := range analyzers </span><span class="cov0" title="0">{
                description := analyzer.Doc
                // берем только первую строку описания
                if newlineIndex := strings.Index(description, "\n"); newlineIndex != -1 </span><span class="cov0" title="0">{
                        description = description[:newlineIndex]
                }</span>
                <span class="cov0" title="0">log.Printf("%d. %s: %s\n", i+1, analyzer.Name, description)</span>
        }
}

// 5. Запускает multichecker.
func main() <span class="cov0" title="0">{
        log.SetOutput(os.Stdout)
        log.SetFlags(0)

        // Инициализируем базовый набор анализаторов
        mychecks := []*analysis.Analyzer{
                // анализаторы из golang.org/x/tools/go/analysis/passes
                printf.Analyzer,
                shadow.Analyzer,
                structtag.Analyzer,

                // собственные публичные анализаторы
                errcheck.Analyzer,
                noexit.Analyzer,

                // exhaustive - проверяет полноту switch для перечислений
                exhaustive.Analyzer,

                // bodyclose - проверяет, что тела HTTP-ответов закрываются
                bodyclose.Analyzer,
        }

        // Загружаем конфигурацию
        cfg, _ := loadConfig(Config)

        // Добавляем анализаторы из staticcheck
        mychecks = addAnalyzers(mychecks, cfg, "staticcheck", getAllStaticcheckAnalyzers())

        // Добавляем анализаторы из stylecheck
        mychecks = addAnalyzers(mychecks, cfg, "stylecheck", getAllStylecheckAnalyzers())

        // Выводим список анализаторов
        printAnalyzersList(mychecks)

        // Запускаем мультичекер
        log.Println("Запуск мультичекера...")
        multichecker.Main(
                mychecks...,
        )
        log.Println("Анализ завершен.")
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package example содержит примеры использования API сервера метрик.
package example

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
)

// ServerAddr - адрес сервера для тестов.
const ServerAddr = "http://localhost:8080"

// Время ожидания для сохранения метрики.
const saveDelay = 100 * time.Millisecond

// SetupTestMetric создает тестовую метрику для примеров.
func SetupTestMetric() error <span class="cov8" title="1">{
        metric := metrics.Metric{
                Name:  "TestGauge",
                MType: "gauge",
                Value: new(float64),
        }
        *metric.Value = 123.45

        body, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metric: %w", err)
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        req, err := http.NewRequestWithContext(
                ctx,
                http.MethodPost,
                ServerAddr+"/update",
                bytes.NewBuffer(body),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Даем время на сохранение метрики
        time.Sleep(saveDelay)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package agent

import (
        "context"
        "crypto/rsa"
        "fmt"
        "log/slog"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/mem"

        "github.com/maynagashev/go-metrics/internal/agent/client"
        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/pkg/random"
)

// Константы для конвертации единиц измерения.
const (
        BytesInKB = 1024
        BytesInMB = BytesInKB * 1024
        BytesInGB = BytesInMB * 1024
)

// Константы для работы агента.
const (
        // Минимальная длина строки для маскирования.
        minMaskLength = 6
        // Таймаут для запросов по умолчанию.
        defaultRequestTimeout = 10 * time.Second
        // Количество видимых символов в начале и конце маскированной строки.
        visibleCharsCount = 2
        // Количество концов строки (начало и конец) для отображения видимых символов.
        stringEndsCount = 2
)

// Job структура для задания воркерам.
type Job struct {
        Metrics []*metrics.Metric
}

// Result структура для результата выполнения задания.
type Result struct {
        Job   Job
        Error error
}

// Agent представляет собой интерфейс для сбора и отправки метрик на сервер.
// Реализует функционал сбора runtime метрик и дополнительных системных метрик,
// а также их отправку на сервер с поддержкой подписи данных.
type Agent interface {
        // Run запускает процесс сбора и отправки метрик.
        Run(ctx context.Context)

        // IsRequestSigningEnabled возвращает true, если включена подпись запросов.
        IsRequestSigningEnabled() bool

        // IsEncryptionEnabled возвращает true, если включено шифрование.
        IsEncryptionEnabled() bool

        // ResetMetrics очищает все собранные метрики.
        ResetMetrics()

        // CollectRuntimeMetrics собирает метрики времени выполнения.
        CollectRuntimeMetrics()

        // CollectAdditionalMetrics собирает дополнительные системные метрики,
        // такие как использование памяти и CPU.
        CollectAdditionalMetrics()

        // GetMetrics возвращает список всех собранных метрик.
        GetMetrics() []*metrics.Metric

        // Shutdown корректно завершает работу агента, дожидаясь завершения всех задач.
        Shutdown()
}

// agent конкретная реализация интерфейса Agent.
type agent struct {
        PollInterval       time.Duration
        ReportInterval     time.Duration
        ServerURL          string
        SendCompressedData bool
        PrivateKey         string
        RateLimit          int
        PublicKey          *rsa.PublicKey // Public key for encryption

        // Конфигурация gRPC
        GRPCEnabled bool   // Использовать gRPC вместо HTTP
        GRPCAddress string // Адрес и порт gRPC сервера
        GRPCTimeout int    // Таймаут для gRPC запросов в секундах
        GRPCRetry   int    // Количество повторных попыток при ошибке gRPC запроса

        gauges       map[string]float64
        counters     map[string]int64
        mu           sync.Mutex
        wg           sync.WaitGroup
        client       client.Client // Клиент для отправки метрик
        pollTicker   *time.Ticker
        reportTicker *time.Ticker
        // Очередь задач на отправку метрик, с буфером в размере RateLimit.
        sendQueue chan Job
        // Очередь результатов выполнения задач, для обработки ошибок.
        resultQueue chan Result
        // Канал для сигнала остановки
        stopCh chan struct{}
}

// New создает новый экземпляр агента.
//
//nolint:gochecknoglobals // используется для подмены в тестах
var New = func(
        url string,
        pollInterval time.Duration,
        reportInterval time.Duration,
        privateKey string,
        rateLimit int,
        publicKey *rsa.PublicKey,
        realIP string,
        grpcEnabled bool, // флаг использования gRPC вместо HTTP
        grpcAddress string, // адрес и порт gRPC сервера
        grpcTimeout int, // таймаут для gRPC запросов в секундах
        grpcRetry int, // количество повторных попыток при ошибке gRPC запроса
) Agent <span class="cov8" title="1">{
        // Создаем фабрику клиентов
        factory := client.NewFactory(
                url,
                grpcAddress,
                grpcEnabled,
                grpcTimeout,
                grpcRetry,
                realIP,
                privateKey,
                publicKey,
        )

        // Создаем клиент через фабрику
        client, err := factory.CreateClient()
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Failed to create client", "error", err)
                // В случае ошибки создания gRPC клиента, будем использовать HTTP клиент
                if grpcEnabled </span><span class="cov8" title="1">{
                        slog.Warn("Falling back to HTTP client")
                        grpcEnabled = false
                        client, _ = factory.CreateClient() // Должно быть успешно, т.к. HTTP клиент не требует соединения при создании
                }</span>
        }

        <span class="cov8" title="1">return &amp;agent{
                ServerURL:          url,
                PollInterval:       pollInterval,
                ReportInterval:     reportInterval,
                SendCompressedData: true, // согласно условиям задачи, отправка сжатых данных включена по умолчанию
                PrivateKey:         privateKey,
                RateLimit:          rateLimit,
                PublicKey:          publicKey,
                GRPCEnabled:        grpcEnabled,
                GRPCAddress:        grpcAddress,
                GRPCTimeout:        grpcTimeout,
                GRPCRetry:          grpcRetry,
                gauges:             make(map[string]float64),
                counters:           make(map[string]int64),
                client:             client,
                pollTicker:         time.NewTicker(pollInterval),
                reportTicker:       time.NewTicker(reportInterval),
                sendQueue:          make(chan Job, rateLimit),
                resultQueue:        make(chan Result, rateLimit),
                stopCh:             make(chan struct{}),
        }</span>
}

// IsRequestSigningEnabled возвращает true, если задан приватный ключ и агент должен отправлять хэш на его основе.
func (a *agent) IsRequestSigningEnabled() bool <span class="cov8" title="1">{
        return a.PrivateKey != ""
}</span>

// IsEncryptionEnabled возвращает true, если задан публичный ключ и агент должен шифровать данные.
func (a *agent) IsEncryptionEnabled() bool <span class="cov8" title="1">{
        return a.PublicKey != nil
}</span>

// Run запускает агента и его воркеры.
func (a *agent) Run(ctx context.Context) <span class="cov8" title="1">{
        slog.Info("Starting agent",
                "server_url", a.ServerURL,
                "poll_interval", a.PollInterval,
                "report_interval", a.ReportInterval,
                "private_key", maskString(a.PrivateKey),
                "rate_limit", a.RateLimit,
                "grpc_enabled", a.GRPCEnabled,
                "grpc_address", a.GRPCAddress)

        // Запускаем воркеры для сбора и отправки метрик
        for i := range a.RateLimit </span><span class="cov8" title="1">{
                a.runWorker(i)
        }</span>
        <span class="cov8" title="1">a.runCollector()
        a.runPolls(ctx)
        a.runReports(ctx)
        a.Shutdown()</span>
}

// maskString маскирует строку, заменяя все символы кроме первых и последних на '*'.
func maskString(s string) string <span class="cov8" title="1">{
        if len(s) &lt; minMaskLength </span><span class="cov8" title="1">{
                return "&lt;empty&gt;"
        }</span>
        // Оставляем по visibleCharsCount символов в начале и конце, остальное заменяем звездочками
        <span class="cov0" title="0">maskLen := len(s) - (visibleCharsCount * stringEndsCount)
        return s[:visibleCharsCount] + strings.Repeat("*", maskLen) + s[len(s)-visibleCharsCount:]</span>
}

// runWorker запускает обработчик задач на отправку метрик.
func (a *agent) runWorker(id int) <span class="cov8" title="1">{
        a.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer a.wg.Done()
                slog.Info("Starting worker", "workerID", id)
                defer slog.Info("Worker shutting down", "workerID", id)

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-a.stopCh:<span class="cov8" title="1">
                                return</span>
                        case job, ok := &lt;-a.sendQueue:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        // Канал закрыт, завершаем работу
                                        return
                                }</span>

                                // Контекст с таймаутом для отправки метрик
                                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), defaultRequestTimeout)
                                err := a.sendMetrics(ctx, job.Metrics, id)
                                cancel()

                                // Отправляем результат в канал для обработки
                                a.resultQueue &lt;- Result{Job: job, Error: err}</span>
                        }
                }
        }()
}

// sendMetrics отправляет метрики на сервер.
func (a *agent) sendMetrics(ctx context.Context, items []*metrics.Metric, workerID int) error <span class="cov0" title="0">{
        slog.Info("Sending metrics batch", "workerID", workerID, "metrics_count", len(items))

        // Используем клиент для отправки метрик
        return a.client.UpdateBatch(ctx, items)
}</span>

// runCollector запускает сборщик результатов.
func (a *agent) runCollector() <span class="cov8" title="1">{
        a.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer a.wg.Done()
                slog.Info("Collector started")
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case result, ok := &lt;-a.resultQueue:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        slog.Info("Result queue closed, collector exiting")
                                        return
                                }</span>
                                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                                        slog.Error("Failed to send metrics", "error", result.Error)
                                }</span> else<span class="cov0" title="0"> {
                                        slog.Info("Metrics sent successfully", "count", len(result.Job.Metrics))
                                }</span>
                        case &lt;-a.stopCh:<span class="cov8" title="1">
                                slog.Info("Stop signal received, collector exiting")
                                return</span>
                        }
                }
        }()
}

// GetMetrics возвращает список всех собранных метрик.
func (a *agent) GetMetrics() []*metrics.Metric <span class="cov8" title="1">{
        startTime := time.Now()
        slog.Debug("Starting metrics preparation for sending")

        items := make([]*metrics.Metric, 0, len(a.gauges)+len(a.counters))

        // Делаем копию метрик, чтобы данные не изменились во время отправки.
        a.mu.Lock()

        gaugesCount := len(a.gauges)
        countersCount := len(a.counters)
        pollCount := a.counters["PollCount"]

        // Проверяем, получен ли сигнал завершения
        select </span>{
        case &lt;-a.stopCh:<span class="cov8" title="1">
                slog.Info(
                        "Shutdown signal received while preparing metrics - ensuring final metrics are sent",
                        "gauges_count",
                        gaugesCount,
                        "counters_count",
                        countersCount,
                        "poll_count",
                        pollCount,
                )</span>
        default:<span class="cov8" title="1">
                slog.Info("Preparing metrics for sending",
                        "gauges_count", gaugesCount,
                        "counters_count", countersCount,
                        "poll_count", pollCount)</span>
        }

        <span class="cov8" title="1">for name, value := range a.gauges </span><span class="cov8" title="1">{
                items = append(items, metrics.NewGauge(name, value))
        }</span>
        <span class="cov8" title="1">for name, value := range a.counters </span><span class="cov8" title="1">{
                items = append(items, metrics.NewCounter(name, value))
        }</span>
        // Обнуляем счетчик PollCount сразу как только подготовили его к отправке.
        // Из минусов: счетчик PollCount будет обнулен, даже если отправка метрик не удалась.
        // Другой вариант: обнулять счетчик PollCount только после успешной отправки метрик.
        <span class="cov8" title="1">a.counters["PollCount"] = 0
        slog.Debug("Reset poll count to zero")

        a.mu.Unlock()

        duration := time.Since(startTime)
        slog.Debug("Metrics preparation completed",
                "metrics_count", len(items),
                "duration_ms", duration.Milliseconds())

        return items</span>
}

// Shutdown корректно завершает работу агента, дожидаясь завершения всех задач.
func (a *agent) Shutdown() <span class="cov8" title="1">{
        slog.Info("======= GRACEFUL SHUTDOWN STARTED =======")

        // Останавливаем тикеры
        if a.pollTicker != nil </span><span class="cov8" title="1">{
                a.pollTicker.Stop()
        }</span>
        <span class="cov8" title="1">if a.reportTicker != nil </span><span class="cov8" title="1">{
                a.reportTicker.Stop()
        }</span>
        <span class="cov8" title="1">slog.Info("Tickers stopped")

        // Сигнализируем о завершении работы
        close(a.stopCh)
        slog.Info("Stop channel closed")

        // Отправляем последние собранные метрики
        metrics := a.GetMetrics()
        if len(metrics) &gt; 0 &amp;&amp; a.client != nil </span><span class="cov8" title="1">{
                slog.Info("Sending final metrics batch before shutdown", "count", len(metrics))

                // Пытаемся отправить метрики напрямую
                ctx, cancel := context.WithTimeout(context.Background(), defaultRequestTimeout)
                err := a.client.UpdateBatch(ctx, metrics)
                cancel()

                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("Failed to send final metrics directly", "error", err)

                        // Если не удалось отправить напрямую, пробуем через очередь
                        select </span>{
                        case a.sendQueue &lt;- Job{Metrics: metrics}:<span class="cov0" title="0">
                                slog.Info("Final metrics queued for sending")</span>
                        default:<span class="cov8" title="1">
                                slog.Error("Failed to queue final metrics, queue might be full")</span>
                        }
                } else<span class="cov0" title="0"> {
                        slog.Info("Final metrics sent successfully")
                }</span>
        } else<span class="cov8" title="1"> {
                slog.Info("No metrics to send before shutdown")
        }</span>

        // Закрываем клиент
        <span class="cov8" title="1">if a.client != nil </span><span class="cov8" title="1">{
                if err := a.client.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to close client", "error", err)
                }</span>
        }

        // Закрываем каналы после отправки всех метрик
        <span class="cov8" title="1">if a.sendQueue != nil </span><span class="cov8" title="1">{
                slog.Info("Closing send queue")
                close(a.sendQueue)
        }</span>

        // Ожидаем завершения всех горутин
        <span class="cov8" title="1">slog.Info("Waiting for all goroutines to finish")
        a.wg.Wait()
        slog.Info("======= GRACEFUL SHUTDOWN COMPLETED =======")</span>
}

// runPolls собирает сведения из системы в отдельной горутине.
func (a *agent) runPolls(ctx context.Context) <span class="cov8" title="1">{
        a.wg.Add(1)
        defer a.wg.Done()

        slog.Info("Poll routine started",
                "poll_interval", a.PollInterval,
                "metrics_storage_size", len(a.gauges)+len(a.counters))

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-a.pollTicker.C:<span class="cov0" title="0">
                        pollStart := time.Now()
                        slog.Debug("Starting metrics collection cycle")

                        a.mu.Lock()
                        // Перезаписываем метрики свежими показаниями
                        a.ResetMetrics()
                        a.CollectRuntimeMetrics()
                        a.CollectAdditionalMetrics()

                        // Увеличиваем счетчик PollCount на 1.
                        a.counters["PollCount"]++
                        // Добавляем обновляемое рандомное значение по условию.
                        a.gauges["RandomValue"] = random.GenerateRandomFloat64()

                        metricsCount := len(a.gauges) + len(a.counters)
                        pollDuration := time.Since(pollStart)

                        // Логируем текущее значение счетчика PollCount в консоль для наглядности работы.
                        slog.Info("Metrics collection completed",
                                "poll_count", a.counters["PollCount"],
                                "metrics_count", metricsCount,
                                "duration_ms", pollDuration.Milliseconds())
                        a.mu.Unlock()</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        slog.Info("Stopping polls due to context cancellation")
                        return</span>
                case &lt;-a.stopCh:<span class="cov0" title="0">
                        slog.Info("Stopping polls due to agent shutdown")
                        return</span>
                }
        }
}

// Создает задачи по отправке метрик в очереди задач на отправку.
func (a *agent) runReports(ctx context.Context) <span class="cov8" title="1">{
        a.wg.Add(1)
        defer a.wg.Done()

        slog.Info("Report routine started",
                "report_interval", a.ReportInterval,
                "server_url", a.ServerURL)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-a.reportTicker.C:<span class="cov0" title="0">
                        reportStart := time.Now()
                        slog.Debug("Starting metrics report cycle")

                        metrics := a.GetMetrics()
                        metricsCount := len(metrics)

                        if metricsCount &gt; 0 </span><span class="cov0" title="0">{
                                slog.Info("Sending metrics to queue",
                                        "metrics_count", metricsCount,
                                        "queue_size", len(a.sendQueue))
                                a.sendQueue &lt;- Job{Metrics: metrics}
                        }</span> else<span class="cov0" title="0"> {
                                slog.Debug("No metrics to send in this report cycle")
                        }</span>

                        <span class="cov0" title="0">reportDuration := time.Since(reportStart)
                        slog.Debug("Report cycle completed",
                                "duration_ms", reportDuration.Milliseconds())</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        slog.Info("Stopping reports due to context cancellation")
                        return</span>
                case &lt;-a.stopCh:<span class="cov0" title="0">
                        slog.Info("Stopping reports due to agent shutdown")
                        return</span>
                }
        }
}

// ResetMetrics очищает все метрики агента, вызываем перед сбором новых метрик.
func (a *agent) ResetMetrics() <span class="cov8" title="1">{
        slog.Debug("Resetting metrics before collection")
        a.gauges = make(map[string]float64)
        a.counters = make(map[string]int64)
}</span>

// CollectRuntimeMetrics собирает метрики времени выполнения.
func (a *agent) CollectRuntimeMetrics() <span class="cov8" title="1">{
        // Проверяем сигнал остановки перед сбором метрик
        select </span>{
        case &lt;-a.stopCh:<span class="cov0" title="0">
                slog.Info("Shutdown signal received, skipping runtime metrics collection")
                return</span>
        default:<span class="cov8" title="1"></span>
                // Продолжаем выполнение
        }

        <span class="cov8" title="1">slog.Debug("Starting runtime metrics collection")
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        a.gauges["Alloc"] = float64(m.Alloc)
        a.gauges["BuckHashSys"] = float64(m.BuckHashSys)
        a.gauges["Frees"] = float64(m.Frees)
        a.gauges["GCCPUFraction"] = m.GCCPUFraction
        a.gauges["GCSys"] = float64(m.GCSys)
        a.gauges["HeapAlloc"] = float64(m.HeapAlloc)
        a.gauges["HeapIdle"] = float64(m.HeapIdle)
        a.gauges["HeapInuse"] = float64(m.HeapInuse)
        a.gauges["HeapObjects"] = float64(m.HeapObjects)
        a.gauges["HeapReleased"] = float64(m.HeapReleased)
        a.gauges["HeapSys"] = float64(m.HeapSys)
        a.gauges["LastGC"] = float64(m.LastGC)
        a.gauges["Lookups"] = float64(m.Lookups)
        a.gauges["MCacheInuse"] = float64(m.MCacheInuse)
        a.gauges["MCacheSys"] = float64(m.MCacheSys)
        a.gauges["MSpanInuse"] = float64(m.MSpanInuse)
        a.gauges["MSpanSys"] = float64(m.MSpanSys)
        a.gauges["Mallocs"] = float64(m.Mallocs)
        a.gauges["NextGC"] = float64(m.NextGC)
        a.gauges["NumForcedGC"] = float64(m.NumForcedGC)
        a.gauges["NumGC"] = float64(m.NumGC)
        a.gauges["OtherSys"] = float64(m.OtherSys)
        a.gauges["PauseTotalNs"] = float64(m.PauseTotalNs)
        a.gauges["StackInuse"] = float64(m.StackInuse)
        a.gauges["StackSys"] = float64(m.StackSys)
        a.gauges["Sys"] = float64(m.Sys)
        a.gauges["TotalAlloc"] = float64(m.TotalAlloc)

        slog.Debug("Runtime metrics collection completed",
                "metrics_count", len(a.gauges),
                "heap_alloc_mb", float64(m.HeapAlloc)/BytesInMB,
                "sys_mb", float64(m.Sys)/BytesInMB)</span>
}

// CollectAdditionalMetrics собирает дополнительные метрики системы.
func (a *agent) CollectAdditionalMetrics() <span class="cov8" title="1">{
        // Проверяем сигнал остановки перед сбором метрик
        select </span>{
        case &lt;-a.stopCh:<span class="cov0" title="0">
                slog.Info("Shutdown signal received, skipping additional metrics collection")
                return</span>
        default:<span class="cov8" title="1"></span>
                // Продолжаем выполнение
        }

        <span class="cov8" title="1">slog.Debug("Starting additional system metrics collection")

        v, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to collect virtual memory metrics", "error", err)
                return
        }</span>
        <span class="cov8" title="1">a.gauges["TotalMemory"] = float64(v.Total)
        a.gauges["FreeMemory"] = float64(v.Free)

        slog.Debug("Memory metrics collected",
                "total_memory_gb", float64(v.Total)/BytesInGB,
                "free_memory_gb", float64(v.Free)/BytesInGB,
                "used_percent", v.UsedPercent)

        c, err := cpu.Percent(0, true)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to collect CPU metrics", "error", err)
                return
        }</span>

        <span class="cov8" title="1">cpuCount := 0
        for i, percent := range c </span><span class="cov8" title="1">{
                a.gauges[fmt.Sprintf("CPUutilization%d", i+1)] = percent
                cpuCount++
        }</span>

        <span class="cov8" title="1">slog.Debug("CPU metrics collection completed", "cpu_count", cpuCount)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package client

import (
        "context"
        "crypto/rsa"
        "fmt"
        "log/slog"

        "github.com/maynagashev/go-metrics/internal/agent/grpc"
        "github.com/maynagashev/go-metrics/internal/agent/http"
        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
)

// Client интерфейс для клиента метрик.
type Client interface {
        // UpdateMetric отправляет метрику на сервер.
        UpdateMetric(ctx context.Context, metric *metrics.Metric) error

        // UpdateBatch отправляет пакет метрик на сервер.
        UpdateBatch(ctx context.Context, metrics []*metrics.Metric) error

        // Ping проверяет соединение с сервером.
        Ping(ctx context.Context) error

        // Close закрывает клиент.
        Close() error
}

// Factory фабрика для создания клиентов.
type Factory struct {
        httpServerAddr string
        grpcServerAddr string
        grpcEnabled    bool
        grpcTimeout    int
        grpcRetry      int
        realIP         string
        privateKey     string
        publicKey      *rsa.PublicKey
}

// NewFactory создает новую фабрику клиентов.
func NewFactory(
        httpServerAddr, grpcServerAddr string,
        grpcEnabled bool,
        grpcTimeout, grpcRetry int,
        realIP, privateKey string,
        publicKey *rsa.PublicKey,
) *Factory <span class="cov8" title="1">{
        return &amp;Factory{
                httpServerAddr: httpServerAddr,
                grpcServerAddr: grpcServerAddr,
                grpcEnabled:    grpcEnabled,
                grpcTimeout:    grpcTimeout,
                grpcRetry:      grpcRetry,
                realIP:         realIP,
                privateKey:     privateKey,
                publicKey:      publicKey,
        }
}</span>

// CreateClient создает клиент в зависимости от конфигурации.
func (f *Factory) CreateClient() (Client, error) <span class="cov8" title="1">{
        if f.grpcEnabled </span><span class="cov8" title="1">{
                slog.Info("using gRPC client", "address", f.grpcServerAddr)
                return f.createGRPCClient()
        }</span>

        <span class="cov8" title="1">slog.Info("using HTTP client", "address", f.httpServerAddr)
        return f.createHTTPClient()</span>
}

// createGRPCClient создает gRPC клиент.
func (f *Factory) createGRPCClient() (Client, error) <span class="cov8" title="1">{
        client, err := grpc.New(
                f.grpcServerAddr,
                f.grpcTimeout,
                f.grpcRetry,
                f.realIP,
                f.privateKey,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create gRPC client: %w", err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// createHTTPClient создает HTTP клиент.
func (f *Factory) createHTTPClient() (Client, error) <span class="cov8" title="1">{
        client := http.New(
                f.httpServerAddr,
                f.privateKey,
                f.publicKey,
                f.realIP,
        )

        return client, nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package grpc

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/metadata"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/grpc/pb"
)

// Client представляет gRPC клиент для отправки метрик.
type Client struct {
        address    string        // адрес gRPC сервера
        timeout    time.Duration // таймаут для запросов
        maxRetries int           // максимальное количество повторных попыток
        conn       *grpc.ClientConn
        client     pb.MetricsServiceClient
        realIP     string // IP-адрес для заголовка X-Real-IP
        privateKey string // приватный ключ для подписи запросов
}

// New создает новый gRPC клиент.
func New(address string, timeout int, maxRetries int, realIP, privateKey string) (*Client, error) <span class="cov8" title="1">{
        // Создаем соединение с сервером
        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
        defer cancel()

        // Устанавливаем соединение без TLS (в будущем можно добавить TLS)
        conn, err := grpc.DialContext(
                ctx,
                address,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithBlock(),
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to gRPC server: %w", err)
        }</span>

        // Создаем клиент
        <span class="cov0" title="0">client := pb.NewMetricsServiceClient(conn)

        return &amp;Client{
                address:    address,
                timeout:    time.Duration(timeout) * time.Second,
                maxRetries: maxRetries,
                conn:       conn,
                client:     client,
                realIP:     realIP,
                privateKey: privateKey,
        }, nil</span>
}

// Close закрывает соединение с сервером.
func (c *Client) Close() error <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                return c.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// createContext создает контекст с метаданными и таймаутом.
func (c *Client) createContext(parent context.Context) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        // Создаем контекст с таймаутом
        ctx, cancel := context.WithTimeout(parent, c.timeout)

        // Добавляем метаданные (X-Real-IP)
        if c.realIP != "" </span><span class="cov0" title="0">{
                md := metadata.New(map[string]string{
                        "X-Real-IP": c.realIP,
                })
                ctx = metadata.NewOutgoingContext(ctx, md)
        }</span>

        // TODO: добавить подпись запроса (HMAC-SHA256) если указан privateKey

        <span class="cov0" title="0">return ctx, cancel</span>
}

// withRetry выполняет операцию с повторными попытками при ошибке.
func (c *Client) withRetry(ctx context.Context, operation func(context.Context) error) error <span class="cov0" title="0">{
        var err error
        retryIntervals := []time.Duration{1 * time.Second, 3 * time.Second, 5 * time.Second}

        // Выполняем операцию с учетом повторных попыток
        for attempt := 0; attempt &lt;= c.maxRetries; attempt++ </span><span class="cov0" title="0">{
                // Создаем контекст для текущей попытки
                opCtx, cancel := c.createContext(ctx)

                // Выполняем операцию
                err = operation(opCtx)
                cancel()

                // Если операция успешна или контекст завершен, выходим из цикла
                if err == nil || ctx.Err() != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Если это последняя попытка, возвращаем ошибку
                <span class="cov0" title="0">if attempt == c.maxRetries </span><span class="cov0" title="0">{
                        break</span>
                }

                // Определяем интервал для следующей попытки
                <span class="cov0" title="0">retryInterval := time.Second
                if attempt &lt; len(retryIntervals) </span><span class="cov0" title="0">{
                        retryInterval = retryIntervals[attempt]
                }</span>

                <span class="cov0" title="0">slog.Warn("gRPC request failed, retrying",
                        "error", err,
                        "attempt", attempt+1,
                        "maxRetries", c.maxRetries,
                        "retryIn", retryInterval)

                // Ждем перед следующей попыткой
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(retryInterval):<span class="cov0" title="0"></span>
                        // Продолжаем выполнение
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("operation failed after %d attempts: %w", c.maxRetries+1, err)</span>
}

// UpdateMetric отправляет метрику на сервер.
func (c *Client) UpdateMetric(ctx context.Context, metric *metrics.Metric) error <span class="cov0" title="0">{
        // Преобразуем метрику из доменной модели в protobuf
        protoMetric := metricToProto(metric)

        // Создаем запрос
        request := &amp;pb.UpdateRequest{
                Metric: protoMetric,
        }

        // Отправляем запрос с повторными попытками
        return c.withRetry(ctx, func(opCtx context.Context) error </span><span class="cov0" title="0">{
                _, err := c.client.Update(opCtx, request)
                return err
        }</span>)
}

// UpdateBatch отправляет пакет метрик на сервер.
func (c *Client) UpdateBatch(ctx context.Context, metrics []*metrics.Metric) error <span class="cov0" title="0">{
        // Если метрик нет, ничего не делаем
        if len(metrics) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Преобразуем метрики из доменной модели в protobuf
        <span class="cov0" title="0">protoMetrics := make([]*pb.Metric, 0, len(metrics))
        for _, m := range metrics </span><span class="cov0" title="0">{
                protoMetrics = append(protoMetrics, metricToProto(m))
        }</span>

        // Создаем запрос
        <span class="cov0" title="0">request := &amp;pb.UpdateBatchRequest{
                Metrics: protoMetrics,
        }

        // Отправляем запрос с повторными попытками
        return c.withRetry(ctx, func(opCtx context.Context) error </span><span class="cov0" title="0">{
                response, err := c.client.UpdateBatch(opCtx, request)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Проверяем успешность операции
                <span class="cov0" title="0">if !response.GetSuccess() </span><span class="cov0" title="0">{
                        return fmt.Errorf("server returned error: %s", response.GetError())
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

// StreamMetrics отправляет метрики потоком на сервер.
func (c *Client) StreamMetrics(ctx context.Context, metrics []*metrics.Metric) error <span class="cov0" title="0">{
        // Если метрик нет, ничего не делаем
        if len(metrics) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Отправляем запрос с повторными попытками
        <span class="cov0" title="0">return c.withRetry(ctx, func(opCtx context.Context) error </span><span class="cov0" title="0">{
                // Открываем поток
                stream, err := c.client.StreamMetrics(opCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open stream: %w", err)
                }</span>

                // Отправляем метрики в поток
                <span class="cov0" title="0">for _, m := range metrics </span><span class="cov0" title="0">{
                        protoMetric := metricToProto(m)
                        if sendErr := stream.Send(protoMetric); sendErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to send metric: %w", sendErr)
                        }</span>
                }

                // Закрываем поток и получаем ответ
                <span class="cov0" title="0">response, err := stream.CloseAndRecv()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close stream: %w", err)
                }</span>

                // Проверяем успешность операции
                <span class="cov0" title="0">if !response.GetSuccess() </span><span class="cov0" title="0">{
                        return fmt.Errorf("server returned error: %s", response.GetError())
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

// Ping проверяет соединение с сервером.
func (c *Client) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return c.withRetry(ctx, func(opCtx context.Context) error </span><span class="cov0" title="0">{
                response, err := c.client.Ping(opCtx, &amp;pb.PingRequest{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Проверяем успешность операции
                <span class="cov0" title="0">if !response.GetSuccess() </span><span class="cov0" title="0">{
                        return fmt.Errorf("server returned error: %s", response.GetError())
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

// metricToProto преобразует метрику из доменной модели в protobuf.
func metricToProto(metric *metrics.Metric) *pb.Metric <span class="cov0" title="0">{
        protoMetric := &amp;pb.Metric{
                Name: metric.Name,
        }

        // Устанавливаем тип метрики
        switch metric.MType </span>{
        case metrics.TypeGauge:<span class="cov0" title="0">
                protoMetric.Type = pb.MetricType_GAUGE
                if metric.Value != nil </span><span class="cov0" title="0">{
                        value := *metric.Value
                        protoMetric.Value = &amp;value
                }</span>
        case metrics.TypeCounter:<span class="cov0" title="0">
                protoMetric.Type = pb.MetricType_COUNTER
                if metric.Delta != nil </span><span class="cov0" title="0">{
                        delta := *metric.Delta
                        protoMetric.Delta = &amp;delta
                }</span>
        }

        <span class="cov0" title="0">return protoMetric</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package http

import (
        "context"
        "crypto/rsa"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "time"

        "github.com/go-resty/resty/v2"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/pkg/crypto"
        "github.com/maynagashev/go-metrics/pkg/middleware/gzip"
        "github.com/maynagashev/go-metrics/pkg/sign"
)

const (
        maxSendRetries = 3
        backoffFactor  = 2
)

// Client представляет HTTP клиент для отправки метрик.
type Client struct {
        serverURL          string
        client             *resty.Client
        privateKey         string
        publicKey          *rsa.PublicKey
        sendCompressedData bool
}

// New создает новый HTTP клиент.
func New(serverURL, privateKey string, publicKey *rsa.PublicKey, realIP string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                serverURL:          serverURL,
                client:             initHTTPClient(realIP),
                privateKey:         privateKey,
                publicKey:          publicKey,
                sendCompressedData: true, // согласно условиям задачи, отправка сжатых данных включена по умолчанию
        }
}</span>

// Close ничего не делает, т.к. HTTP клиент не требует закрытия.
func (c *Client) Close() error <span class="cov8" title="1">{
        return nil
}</span>

// UpdateMetric отправляет метрику на сервер.
func (c *Client) UpdateMetric(ctx context.Context, metric *metrics.Metric) error <span class="cov0" title="0">{
        return c.UpdateBatch(ctx, []*metrics.Metric{metric})
}</span>

// UpdateBatch отправляет пакет метрик на сервер.
func (c *Client) UpdateBatch(ctx context.Context, metrics []*metrics.Metric) error <span class="cov8" title="1">{
        // Если метрик нет, ничего не делаем
        if len(metrics) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Отправляем все метрики пачкой на маршрут /updates
        // Ошибки подключения при отправке метрик можно повторить, но не более maxSendRetries раз
        <span class="cov8" title="1">for i := 0; i &lt;= maxSendRetries; i++ </span><span class="cov8" title="1">{
                // Проверяем, не отменен ли контекст
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Пауза перед повторной отправкой
                <span class="cov8" title="1">if i &gt; 0 </span><span class="cov0" title="0">{
                        sleepSeconds := i*backoffFactor - 1 // 1, 3, 5, 7, 9, 11, ...
                        slog.Info(
                                fmt.Sprintf("retrying to send metrics (try=%d) in %d seconds", i, sleepSeconds),
                        )

                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(time.Duration(sleepSeconds) * time.Second):<span class="cov0" title="0"></span>
                                // Продолжаем выполнение
                        }
                }

                <span class="cov8" title="1">err := c.makeUpdatesRequest(ctx, metrics, i)
                // Если нет ошибок выходим из цикла и функции
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Логируем ошибку
                <span class="cov8" title="1">slog.Error(
                        fmt.Sprintf("failed to send metrics (try=%d): %s", i, err),
                        "metrics", metrics,
                )

                // Если ошибка не retriable, то выходим из цикла и функции, иначе продолжаем попытки
                if !isRetriableSendError(err) </span><span class="cov8" title="1">{
                        slog.Debug("non-retriable error, stopping retries", "err", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return errors.New("failed to send metrics after all retries")</span>
}

// Ping проверяет соединение с сервером.
func (c *Client) Ping(ctx context.Context) error <span class="cov0" title="0">{
        req := c.client.R()
        url := fmt.Sprintf("%s/ping", c.serverURL)

        // Устанавливаем таймаут из контекста
        req.SetContext(ctx)

        res, err := req.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if res.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ping failed with status code: %d", res.StatusCode())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// isRequestSigningEnabled возвращает true, если задан приватный ключ и агент должен отправлять хэш на его основе.
func (c *Client) isRequestSigningEnabled() bool <span class="cov8" title="1">{
        return c.privateKey != ""
}</span>

// isEncryptionEnabled возвращает true, если задан публичный ключ и агент должен шифровать данные.
func (c *Client) isEncryptionEnabled() bool <span class="cov8" title="1">{
        return c.publicKey != nil
}</span>

// makeUpdatesRequest отправляет запрос на сервер для обновления метрик.
func (c *Client) makeUpdatesRequest(ctx context.Context, items []*metrics.Metric, try int) error <span class="cov8" title="1">{
        var err error
        url := fmt.Sprintf("%s/updates", c.serverURL)
        slog.Info(
                fmt.Sprintf("sending metrics batch (try=%d)", try),
                "url", url,
                "metrics", items,
        )

        // Создаем новый запрос
        req := c.client.R()
        req.Debug = true // Включаем отладочный режим, чтобы видеть все детали запроса, в частности, использование сжатия
        req.SetHeader("Content-Type", "application/json")
        req.SetContext(ctx)

        // Преобразуем метрики в JSON
        bytesBody, err := json.Marshal(items)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Если задан приватный ключ, добавляем хэш в заголовок запроса
        <span class="cov8" title="1">if c.isRequestSigningEnabled() </span><span class="cov0" title="0">{
                hash := sign.ComputeHMACSHA256(bytesBody, c.privateKey)
                req.SetHeader(sign.HeaderKey, hash)
        }</span>

        // Если включено шифрование, шифруем данные перед отправкой
        <span class="cov8" title="1">if c.isEncryptionEnabled() </span><span class="cov0" title="0">{
                slog.Debug("encrypting data before sending")
                encryptedData, encryptErr := crypto.EncryptLargeData(c.publicKey, bytesBody)
                if encryptErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encrypt data: %w", encryptErr)
                }</span>
                <span class="cov0" title="0">bytesBody = encryptedData
                req.SetHeader("Content-Encrypted", "true")</span>
        }

        // Если включена сразу отправка сжатых данных, добавляем соответствующий заголовок
        // Go клиент автоматом также добавляет заголовок "Accept-Encoding: gzip"
        <span class="cov8" title="1">if c.sendCompressedData </span><span class="cov8" title="1">{
                req.SetHeader("Content-Encoding", "gzip")
                bytesBody, err = gzip.Compress(bytesBody)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">req.SetBody(bytesBody)

        res, err := req.Post(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Обрабатываем ответ сервера
        <span class="cov8" title="1">statusCode := res.StatusCode()
        slog.Debug("received server response",
                "status_code", statusCode,
                "response_body", string(res.Body()))

        if statusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("server returned non-OK response: %d", statusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// isRetriableSendError проверяет, является ли ошибка возможной для повторной отправки.
func isRetriableSendError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Добавляем основные сетевые ошибки, которые можно повторить
        <span class="cov8" title="1">var netErr net.Error
        if errors.As(err, &amp;netErr) &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                return true
        }</span>

        // Добавляем конкретные ошибки, для которых можно делать повторную отправку
        <span class="cov8" title="1">var netOpErr *net.OpError
        if errors.As(err, &amp;netOpErr) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Проверяем на различные DNS ошибки
        <span class="cov8" title="1">var dnsErr *net.DNSError
        if errors.As(err, &amp;dnsErr) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Добавляем проверку на конкретные коды ошибок HTTP
        <span class="cov8" title="1">if errors.Is(err, net.ErrClosed) || errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Для любой Connection refused ошибки повторяем тоже
        <span class="cov8" title="1">if errors.Is(err, errors.New("connection refused")) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Добавляем ошибки TLS, которые могут быть временными
        <span class="cov8" title="1">if errors.Is(err, errors.New("TLS handshake timeout")) </span><span class="cov0" title="0">{
                return true
        }</span>

        // По умолчанию считаем, что ошибку нельзя повторить
        <span class="cov8" title="1">return false</span>
}

// initHTTPClient создает и настраивает HTTP-клиент с перехватчиком для установки заголовка X-Real-IP.
func initHTTPClient(realIP string) *resty.Client <span class="cov8" title="1">{
        client := resty.New().SetHeader("Content-Type", "text/plain")

        // Добавляем перехватчик для установки заголовка X-Real-IP
        client.OnBeforeRequest(func(_ *resty.Client, req *resty.Request) error </span><span class="cov8" title="1">{
                // Если указан явный IP-адрес, используем его
                if realIP != "" </span><span class="cov0" title="0">{
                        req.SetHeader("X-Real-IP", realIP)
                        slog.Debug("set X-Real-IP header (explicit)", "ip", realIP)
                        return nil
                }</span>

                // Иначе получаем исходящий IP-адрес автоматически
                <span class="cov8" title="1">hostIP, err := getOutboundIP()
                if err == nil </span><span class="cov8" title="1">{
                        // Устанавливаем заголовок X-Real-IP
                        req.SetHeader("X-Real-IP", hostIP.String())
                        slog.Debug("set X-Real-IP header (auto-detected)", "ip", hostIP.String())
                }</span> else<span class="cov0" title="0"> {
                        slog.Error("failed to set X-Real-IP header", "error", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return client</span>
}

// getOutboundIP получает исходящий IP-адрес для текущего хоста.
func getOutboundIP() (net.IP, error) <span class="cov8" title="1">{
        conn, err := net.Dial("udp", "8.8.8.8:80")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        localAddr, ok := conn.LocalAddr().(*net.UDPAddr)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected address type: %T", conn.LocalAddr())
        }</span>
        <span class="cov8" title="1">return localAddr.IP, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package agent

import (
        "errors"
        "log/slog"
        "net"
)

// ErrNoOutboundIP возникает, когда не удается определить исходящий IP-адрес.
var ErrNoOutboundIP = errors.New("no outbound IP address found")

// GetOutboundIP определяет исходящий IP-адрес, используемый для подключения к внешним ресурсам.
// Функция создает UDP-соединение (которое не устанавливает реальное соединение) с публичным IP-адресом
// и использует локальный адрес этого соединения как исходящий IP.
func GetOutboundIP() (net.IP, error) <span class="cov8" title="1">{
        // Используем 8.8.8.8:80 (Google DNS) как адрес назначения
        // Это не устанавливает реальное соединение, а только определяет, какой сетевой интерфейс будет использован
        conn, err := net.Dial("udp", "8.8.8.8:80")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to determine outbound IP", "error", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        // Получаем локальный адрес соединения
        localAddr, ok := conn.LocalAddr().(*net.UDPAddr)
        if !ok </span><span class="cov0" title="0">{
                slog.Error("failed to convert local address to UDP address")
                return nil, ErrNoOutboundIP
        }</span>

        // Проверяем, что IP-адрес не nil и не равен 0.0.0.0
        <span class="cov8" title="1">if localAddr.IP == nil || localAddr.IP.IsUnspecified() </span><span class="cov0" title="0">{
                slog.Error("local IP address is nil or unspecified")
                return nil, ErrNoOutboundIP
        }</span>

        <span class="cov8" title="1">slog.Debug("determined outbound IP", "ip", localAddr.IP.String())
        return localAddr.IP, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package metrics определяет основные структуры и типы для работы с метриками.
// Содержит определения типов метрик, их форматов и методов валидации.
package metrics

import (
        "encoding/json"
        "fmt"
        "strconv"
)

type MetricType string

const (
        TypeCounter MetricType = "counter"
        TypeGauge   MetricType = "gauge"
)

type Metric struct {
        Name  string     `json:"id"`              // Имя метрики
        MType MetricType `json:"type"`            // Параметр, принимающий значение gauge или counter
        Delta *int64     `json:"delta,omitempty"` // Значение метрики в случае передачи counter
        Value *float64   `json:"value,omitempty"` // Значение метрики в случае передачи gauge
}

func NewMetric(name string, mType MetricType, delta *int64, value *float64) *Metric <span class="cov8" title="1">{
        return &amp;Metric{
                Name:  name,
                MType: mType,
                Delta: delta,
                Value: value,
        }
}</span>

func NewCounter(id string, delta int64) *Metric <span class="cov8" title="1">{
        return NewMetric(id, TypeCounter, &amp;delta, nil)
}</span>

func NewGauge(id string, value float64) *Metric <span class="cov8" title="1">{
        return NewMetric(id, TypeGauge, nil, &amp;value)
}</span>

func (m *Metric) String() string <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return "&lt;nil&gt;"
        }</span>
        <span class="cov8" title="1">if m.Delta != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Metric{Name: %s, Type: %s, Delta: %d}", m.Name, m.MType, *m.Delta)
        }</span>
        <span class="cov8" title="1">if m.Value != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Metric{Name: %s, Type: %s, Value: %f}", m.Name, m.MType, *m.Value)
        }</span>
        // Значение метрики может быть не задано в структуре,
        // т.к. эта же структура используется для парсинга json в запросе получения значения метрики.
        <span class="cov8" title="1">return fmt.Sprintf("Metric{Name: %s, Type: %s}", m.Name, m.MType)</span>
}

func (m *Metric) ValueString() string <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return "&lt;nil&gt;"
        }</span>
        <span class="cov8" title="1">switch m.MType </span>{
        case TypeCounter:<span class="cov8" title="1">
                return strconv.FormatInt(*m.Delta, 10)</span>
        case TypeGauge:<span class="cov8" title="1">
                return strconv.FormatFloat(*m.Value, 'f', -1, 64)</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (m *Metric) ToJSON() []byte <span class="cov8" title="1">{
        encoded, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return encoded</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v3.21.12
// source: proto/metrics.proto

package pb

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Тип метрики
type MetricType int32

const (
        MetricType_GAUGE   MetricType = 0
        MetricType_COUNTER MetricType = 1
)

// Enum value maps for MetricType.
var (
        MetricType_name = map[int32]string{
                0: "GAUGE",
                1: "COUNTER",
        }
        MetricType_value = map[string]int32{
                "GAUGE":   0,
                "COUNTER": 1,
        }
)

func (x MetricType) Enum() *MetricType <span class="cov0" title="0">{
        p := new(MetricType)
        *p = x
        return p
}</span>

func (x MetricType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (MetricType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_proto_metrics_proto_enumTypes[0].Descriptor()
}</span>

func (MetricType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_proto_metrics_proto_enumTypes[0]
}</span>

func (x MetricType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use MetricType.Descriptor instead.
func (MetricType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{0}
}</span>

// Метрика
type Metric struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Type          MetricType             `protobuf:"varint,2,opt,name=type,proto3,enum=metrics.MetricType" json:"type,omitempty"`
        Delta         *int64                 `protobuf:"varint,3,opt,name=delta,proto3,oneof" json:"delta,omitempty"`
        Value         *float64               `protobuf:"fixed64,4,opt,name=value,proto3,oneof" json:"value,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Metric) Reset() <span class="cov0" title="0">{
        *x = Metric{}
        mi := &amp;file_proto_metrics_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Metric) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Metric) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Metric) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Metric.ProtoReflect.Descriptor instead.
func (*Metric) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Metric) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Metric) GetType() MetricType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return MetricType_GAUGE</span>
}

func (x *Metric) GetDelta() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Delta != nil </span><span class="cov0" title="0">{
                return *x.Delta
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Metric) GetValue() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Value != nil </span><span class="cov0" title="0">{
                return *x.Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Запрос на обновление метрики
type UpdateRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Metric        *Metric                `protobuf:"bytes,1,opt,name=metric,proto3" json:"metric,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateRequest{}
        mi := &amp;file_proto_metrics_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateRequest.ProtoReflect.Descriptor instead.
func (*UpdateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UpdateRequest) GetMetric() *Metric <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metric
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Запрос на пакетное обновление метрик
type UpdateBatchRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Metrics       []*Metric              `protobuf:"bytes,1,rep,name=metrics,proto3" json:"metrics,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateBatchRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateBatchRequest{}
        mi := &amp;file_proto_metrics_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateBatchRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateBatchRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateBatchRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateBatchRequest.ProtoReflect.Descriptor instead.
func (*UpdateBatchRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{2}
}</span>

func (x *UpdateBatchRequest) GetMetrics() []*Metric <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metrics
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Запрос на получение значения метрики
type GetValueRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Type          MetricType             `protobuf:"varint,2,opt,name=type,proto3,enum=metrics.MetricType" json:"type,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetValueRequest) Reset() <span class="cov0" title="0">{
        *x = GetValueRequest{}
        mi := &amp;file_proto_metrics_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetValueRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetValueRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetValueRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetValueRequest.ProtoReflect.Descriptor instead.
func (*GetValueRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetValueRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetValueRequest) GetType() MetricType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return MetricType_GAUGE</span>
}

// Ответ с метрикой
type MetricResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Metric        *Metric                `protobuf:"bytes,1,opt,name=metric,proto3" json:"metric,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MetricResponse) Reset() <span class="cov0" title="0">{
        *x = MetricResponse{}
        mi := &amp;file_proto_metrics_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MetricResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MetricResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MetricResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MetricResponse.ProtoReflect.Descriptor instead.
func (*MetricResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{4}
}</span>

func (x *MetricResponse) GetMetric() *Metric <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metric
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ответ на пакетное обновление
type UpdateBatchResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateBatchResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateBatchResponse{}
        mi := &amp;file_proto_metrics_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateBatchResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateBatchResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateBatchResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateBatchResponse.ProtoReflect.Descriptor instead.
func (*UpdateBatchResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UpdateBatchResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateBatchResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Запрос на проверку соединения с БД
type PingRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingRequest) Reset() <span class="cov0" title="0">{
        *x = PingRequest{}
        mi := &amp;file_proto_metrics_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{6}
}</span>

// Ответ на проверку соединения с БД
type PingResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingResponse) Reset() <span class="cov0" title="0">{
        *x = PingResponse{}
        mi := &amp;file_proto_metrics_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_metrics_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{7}
}</span>

func (x *PingResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *PingResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_proto_metrics_proto protoreflect.FileDescriptor

var file_proto_metrics_proto_rawDesc = string([]byte{
        0x0a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x22, 0x8f,
        0x01, 0x0a, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x27, 0x0a,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x6d, 0x65,
        0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54, 0x79, 0x70, 0x65,
        0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a, 0x05, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x03, 0x48, 0x00, 0x52, 0x05, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x88, 0x01,
        0x01, 0x12, 0x19, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01,
        0x48, 0x01, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x88, 0x01, 0x01, 0x42, 0x08, 0x0a, 0x06,
        0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x22, 0x38, 0x0a, 0x0d, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x27, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72,
        0x69, 0x63, 0x52, 0x06, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x22, 0x3f, 0x0a, 0x12, 0x55, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x29, 0x0a, 0x07, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72,
        0x69, 0x63, 0x52, 0x07, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x22, 0x4e, 0x0a, 0x0f, 0x47,
        0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x27, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
        0x32, 0x13, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69,
        0x63, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x22, 0x39, 0x0a, 0x0e, 0x4d,
        0x65, 0x74, 0x72, 0x69, 0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x27, 0x0a,
        0x06, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e,
        0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x52, 0x06,
        0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x22, 0x45, 0x0a, 0x13, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a,
        0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07,
        0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x0d, 0x0a,
        0x0b, 0x50, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x3e, 0x0a, 0x0c,
        0x50, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07,
        0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73,
        0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2a, 0x24, 0x0a, 0x0a,
        0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54, 0x79, 0x70, 0x65, 0x12, 0x09, 0x0a, 0x05, 0x47, 0x41,
        0x55, 0x47, 0x45, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x45, 0x52,
        0x10, 0x01, 0x32, 0xcb, 0x02, 0x0a, 0x0e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x39, 0x0a, 0x06, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12,
        0x16, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63,
        0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x48, 0x0a, 0x0b, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x12,
        0x1b, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x6d,
        0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x42, 0x61, 0x74,
        0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3d, 0x0a, 0x08, 0x47, 0x65,
        0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x18, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73,
        0x2e, 0x47, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x17, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69,
        0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x33, 0x0a, 0x04, 0x50, 0x69, 0x6e,
        0x67, 0x12, 0x14, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x50, 0x69, 0x6e, 0x67,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x15, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63,
        0x73, 0x2e, 0x50, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x40,
        0x0a, 0x0d, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12,
        0x0f, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63,
        0x1a, 0x1c, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74,
        0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x28, 0x01,
        0x42, 0x34, 0x5a, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6d,
        0x61, 0x79, 0x6e, 0x61, 0x67, 0x61, 0x73, 0x68, 0x65, 0x76, 0x2f, 0x67, 0x6f, 0x2d, 0x6d, 0x65,
        0x74, 0x72, 0x69, 0x63, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x67,
        0x72, 0x70, 0x63, 0x2f, 0x70, 0x62, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_proto_metrics_proto_rawDescOnce sync.Once
        file_proto_metrics_proto_rawDescData []byte
)

func file_proto_metrics_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_metrics_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_metrics_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_metrics_proto_rawDesc), len(file_proto_metrics_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_metrics_proto_rawDescData</span>
}

var file_proto_metrics_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_metrics_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_proto_metrics_proto_goTypes = []any{
        (MetricType)(0),             // 0: metrics.MetricType
        (*Metric)(nil),              // 1: metrics.Metric
        (*UpdateRequest)(nil),       // 2: metrics.UpdateRequest
        (*UpdateBatchRequest)(nil),  // 3: metrics.UpdateBatchRequest
        (*GetValueRequest)(nil),     // 4: metrics.GetValueRequest
        (*MetricResponse)(nil),      // 5: metrics.MetricResponse
        (*UpdateBatchResponse)(nil), // 6: metrics.UpdateBatchResponse
        (*PingRequest)(nil),         // 7: metrics.PingRequest
        (*PingResponse)(nil),        // 8: metrics.PingResponse
}
var file_proto_metrics_proto_depIdxs = []int32{
        0,  // 0: metrics.Metric.type:type_name -&gt; metrics.MetricType
        1,  // 1: metrics.UpdateRequest.metric:type_name -&gt; metrics.Metric
        1,  // 2: metrics.UpdateBatchRequest.metrics:type_name -&gt; metrics.Metric
        0,  // 3: metrics.GetValueRequest.type:type_name -&gt; metrics.MetricType
        1,  // 4: metrics.MetricResponse.metric:type_name -&gt; metrics.Metric
        2,  // 5: metrics.MetricsService.Update:input_type -&gt; metrics.UpdateRequest
        3,  // 6: metrics.MetricsService.UpdateBatch:input_type -&gt; metrics.UpdateBatchRequest
        4,  // 7: metrics.MetricsService.GetValue:input_type -&gt; metrics.GetValueRequest
        7,  // 8: metrics.MetricsService.Ping:input_type -&gt; metrics.PingRequest
        1,  // 9: metrics.MetricsService.StreamMetrics:input_type -&gt; metrics.Metric
        5,  // 10: metrics.MetricsService.Update:output_type -&gt; metrics.MetricResponse
        6,  // 11: metrics.MetricsService.UpdateBatch:output_type -&gt; metrics.UpdateBatchResponse
        5,  // 12: metrics.MetricsService.GetValue:output_type -&gt; metrics.MetricResponse
        8,  // 13: metrics.MetricsService.Ping:output_type -&gt; metrics.PingResponse
        6,  // 14: metrics.MetricsService.StreamMetrics:output_type -&gt; metrics.UpdateBatchResponse
        10, // [10:15] is the sub-list for method output_type
        5,  // [5:10] is the sub-list for method input_type
        5,  // [5:5] is the sub-list for extension type_name
        5,  // [5:5] is the sub-list for extension extendee
        0,  // [0:5] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_metrics_proto_init() }</span>
func file_proto_metrics_proto_init() <span class="cov8" title="1">{
        if File_proto_metrics_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_proto_metrics_proto_msgTypes[0].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_metrics_proto_rawDesc), len(file_proto_metrics_proto_rawDesc)),
                        NumEnums:      1,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_metrics_proto_goTypes,
                DependencyIndexes: file_proto_metrics_proto_depIdxs,
                EnumInfos:         file_proto_metrics_proto_enumTypes,
                MessageInfos:      file_proto_metrics_proto_msgTypes,
        }.Build()
        File_proto_metrics_proto = out.File
        file_proto_metrics_proto_goTypes = nil
        file_proto_metrics_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: proto/metrics.proto

package pb

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MetricsServiceClient is the client API for MetricsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MetricsServiceClient interface {
        // Обновление одиночной метрики
        Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*MetricResponse, error)
        // Пакетное обновление метрик
        UpdateBatch(ctx context.Context, in *UpdateBatchRequest, opts ...grpc.CallOption) (*UpdateBatchResponse, error)
        // Получение значения метрики
        GetValue(ctx context.Context, in *GetValueRequest, opts ...grpc.CallOption) (*MetricResponse, error)
        // Проверка соединения с БД
        Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
        // Потоковая отправка метрик (клиент -&gt; сервер)
        StreamMetrics(ctx context.Context, opts ...grpc.CallOption) (MetricsService_StreamMetricsClient, error)
}

type metricsServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewMetricsServiceClient(cc grpc.ClientConnInterface) MetricsServiceClient <span class="cov0" title="0">{
        return &amp;metricsServiceClient{cc}
}</span>

func (c *metricsServiceClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*MetricResponse, error) <span class="cov0" title="0">{
        out := new(MetricResponse)
        err := c.cc.Invoke(ctx, "/metrics.MetricsService/Update", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metricsServiceClient) UpdateBatch(ctx context.Context, in *UpdateBatchRequest, opts ...grpc.CallOption) (*UpdateBatchResponse, error) <span class="cov0" title="0">{
        out := new(UpdateBatchResponse)
        err := c.cc.Invoke(ctx, "/metrics.MetricsService/UpdateBatch", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metricsServiceClient) GetValue(ctx context.Context, in *GetValueRequest, opts ...grpc.CallOption) (*MetricResponse, error) <span class="cov0" title="0">{
        out := new(MetricResponse)
        err := c.cc.Invoke(ctx, "/metrics.MetricsService/GetValue", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metricsServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) <span class="cov0" title="0">{
        out := new(PingResponse)
        err := c.cc.Invoke(ctx, "/metrics.MetricsService/Ping", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metricsServiceClient) StreamMetrics(ctx context.Context, opts ...grpc.CallOption) (MetricsService_StreamMetricsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;MetricsService_ServiceDesc.Streams[0], "/metrics.MetricsService/StreamMetrics", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metricsServiceStreamMetricsClient{stream}
        return x, nil</span>
}

type MetricsService_StreamMetricsClient interface {
        Send(*Metric) error
        CloseAndRecv() (*UpdateBatchResponse, error)
        grpc.ClientStream
}

type metricsServiceStreamMetricsClient struct {
        grpc.ClientStream
}

func (x *metricsServiceStreamMetricsClient) Send(m *Metric) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metricsServiceStreamMetricsClient) CloseAndRecv() (*UpdateBatchResponse, error) <span class="cov0" title="0">{
        if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">m := new(UpdateBatchResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// MetricsServiceServer is the server API for MetricsService service.
// All implementations must embed UnimplementedMetricsServiceServer
// for forward compatibility
type MetricsServiceServer interface {
        // Обновление одиночной метрики
        Update(context.Context, *UpdateRequest) (*MetricResponse, error)
        // Пакетное обновление метрик
        UpdateBatch(context.Context, *UpdateBatchRequest) (*UpdateBatchResponse, error)
        // Получение значения метрики
        GetValue(context.Context, *GetValueRequest) (*MetricResponse, error)
        // Проверка соединения с БД
        Ping(context.Context, *PingRequest) (*PingResponse, error)
        // Потоковая отправка метрик (клиент -&gt; сервер)
        StreamMetrics(MetricsService_StreamMetricsServer) error
        mustEmbedUnimplementedMetricsServiceServer()
}

// UnimplementedMetricsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMetricsServiceServer struct {
}

func (UnimplementedMetricsServiceServer) Update(context.Context, *UpdateRequest) (*MetricResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}</span>
func (UnimplementedMetricsServiceServer) UpdateBatch(context.Context, *UpdateBatchRequest) (*UpdateBatchResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateBatch not implemented")
}</span>
func (UnimplementedMetricsServiceServer) GetValue(context.Context, *GetValueRequest) (*MetricResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetValue not implemented")
}</span>
func (UnimplementedMetricsServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedMetricsServiceServer) StreamMetrics(MetricsService_StreamMetricsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method StreamMetrics not implemented")
}</span>
func (UnimplementedMetricsServiceServer) mustEmbedUnimplementedMetricsServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeMetricsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetricsServiceServer will
// result in compilation errors.
type UnsafeMetricsServiceServer interface {
        mustEmbedUnimplementedMetricsServiceServer()
}

func RegisterMetricsServiceServer(s grpc.ServiceRegistrar, srv MetricsServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;MetricsService_ServiceDesc, srv)
}</span>

func _MetricsService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).Update(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/metrics.MetricsService/Update",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).Update(ctx, req.(*UpdateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MetricsService_UpdateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateBatchRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).UpdateBatch(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/metrics.MetricsService/UpdateBatch",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).UpdateBatch(ctx, req.(*UpdateBatchRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MetricsService_GetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetValueRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).GetValue(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/metrics.MetricsService/GetValue",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).GetValue(ctx, req.(*GetValueRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MetricsService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).Ping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/metrics.MetricsService/Ping",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetricsServiceServer).Ping(ctx, req.(*PingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MetricsService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetricsServiceServer).StreamMetrics(&amp;metricsServiceStreamMetricsServer{stream})
}</span>

type MetricsService_StreamMetricsServer interface {
        SendAndClose(*UpdateBatchResponse) error
        Recv() (*Metric, error)
        grpc.ServerStream
}

type metricsServiceStreamMetricsServer struct {
        grpc.ServerStream
}

func (x *metricsServiceStreamMetricsServer) SendAndClose(m *UpdateBatchResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metricsServiceStreamMetricsServer) Recv() (*Metric, error) <span class="cov0" title="0">{
        m := new(Metric)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// MetricsService_ServiceDesc is the grpc.ServiceDesc for MetricsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MetricsService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "metrics.MetricsService",
        HandlerType: (*MetricsServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Update",
                        Handler:    _MetricsService_Update_Handler,
                },
                {
                        MethodName: "UpdateBatch",
                        Handler:    _MetricsService_UpdateBatch_Handler,
                },
                {
                        MethodName: "GetValue",
                        Handler:    _MetricsService_GetValue_Handler,
                },
                {
                        MethodName: "Ping",
                        Handler:    _MetricsService_Ping_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "StreamMetrics",
                        Handler:       _MetricsService_StreamMetrics_Handler,
                        ClientStreams: true,
                },
        },
        Metadata: "proto/metrics.proto",
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package app реализует основную логику работы HTTP-сервера.
// Содержит инициализацию и запуск сервера, а также обработку конфигурации.
package app

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "go.uber.org/zap"
)

const (
        DefaultReadTimeout  = 5 * time.Second
        DefaultWriteTimeout = 10 * time.Second
        DefaultIdleTimeout  = 120 * time.Second
        ShutdownTimeout     = 30 * time.Second
        DataSavingTimeout   = 5 * time.Second // Время ожидания сохранения данных при shutdown
)

// Server представляет собой HTTP-сервер для сбора метрик.
// Обрабатывает запросы от агентов и сохраняет метрики в хранилище.
type Server struct {
        cfg *Config
}

// New создает новый экземпляр сервера с указанной конфигурацией.
func New(cfg *Config) *Server <span class="cov8" title="1">{
        return &amp;Server{
                cfg: cfg,
        }
}</span>

// Start запускает HTTP-сервер с указанным обработчиком и логгером.
// Настраивает таймауты и другие параметры сервера.
// Обрабатывает сигналы SIGTERM, SIGINT, SIGQUIT для graceful shutdown.
func (s *Server) Start(log *zap.Logger, handler http.Handler) <span class="cov0" title="0">{
        log.Info("starting server", zap.Any("config", s.cfg))

        httpServer := &amp;http.Server{
                Addr:    s.cfg.Addr,
                Handler: handler,
                // Настройка таймаутов для сервера по рекомендациям линтера gosec
                ReadTimeout:  DefaultReadTimeout,
                WriteTimeout: DefaultWriteTimeout,
                IdleTimeout:  DefaultIdleTimeout,
        }

        // Канал для получения ошибок от запущенного сервера
        serverErrors := make(chan error, 1)

        // Запускаем сервер в отдельной горутине
        go func() </span><span class="cov0" title="0">{
                log.Info("server is listening", zap.String("addr", s.cfg.Addr))
                serverErrors &lt;- httpServer.ListenAndServe()
        }</span>()

        // Канал для получения сигналов от ОС
        <span class="cov0" title="0">shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        // Блокируемся до получения сигнала или ошибки
        select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                log.Fatal("server error", zap.Error(err))</span>
        case sig := &lt;-shutdown:<span class="cov0" title="0">
                log.Info("shutdown signal received", zap.String("signal", sig.String()))

                // Создаем контекст с таймаутом для graceful shutdown
                ctx, cancel := context.WithTimeout(context.Background(), ShutdownTimeout)
                defer cancel()

                // Сначала останавливаем прием новых запросов
                if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error("server shutdown failed", zap.Error(err))
                        if closeErr := httpServer.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                log.Error("server close failed", zap.Error(closeErr))
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Info("server shutdown completed")
                }</span>

                // Даем время на завершение текущих операций и сохранение данных
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Error("shutdown timeout exceeded")</span>
                case &lt;-time.After(DataSavingTimeout):<span class="cov0" title="0"> // Дополнительное время для сохранения данных
                        log.Info("all pending operations completed")</span>
                }
        }
}

// GetStoreInterval возвращает интервал сохранения метрик в секундах.
func (s *Server) GetStoreInterval() int <span class="cov8" title="1">{
        return s.cfg.StoreInterval
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package app

import (
        "crypto/rsa"
        "log/slog"
        "os"

        "github.com/maynagashev/go-metrics/pkg/crypto"
)

// Config содержит конфигурацию сервера метрик.
type Config struct {
        // Addr адрес и порт для запуска сервера.
        Addr string
        // Интервал сохранения метрик на сервере в секундах.
        StoreInterval int
        // Полное имя файла, в который будут сохранены метрики.
        FileStoragePath string
        // Загружать или нет ранее сохраненные метрики из файла.
        Restore bool
        // Параметры базы данных
        Database DatabaseConfig
        // Параметры gRPC сервера
        GRPC GRPCConfig
        // Приватный ключ для подписи метрик.
        PrivateKey string
        // Включить профилирование через pprof
        EnablePprof bool
        // Приватный ключ для расшифровки данных.
        PrivateRSAKey *rsa.PrivateKey
        // Конфигурационный файл
        ConfigFile string
        // TrustedSubnet CIDR доверенной подсети для проверки IP-адресов агентов
        TrustedSubnet string
}

// DatabaseConfig содержит настройки подключения к базе данных.
type DatabaseConfig struct {
        // DSN строка подключения к базе данных.
        DSN string
        // MigrationsPath путь к директории с миграциями.
        MigrationsPath string
}

// GRPCConfig содержит настройки gRPC сервера.
type GRPCConfig struct {
        // Addr адрес и порт для gRPC сервера.
        Addr string
        // Enabled включен ли gRPC сервер.
        Enabled bool
        // MaxConn максимальное количество одновременных соединений.
        MaxConn int
        // Timeout таймаут для gRPC запросов в секундах.
        Timeout int
}

func NewConfig(flags *Flags) *Config <span class="cov8" title="1">{
        cfg := &amp;Config{
                Addr:            flags.Server.Addr,
                StoreInterval:   flags.Server.StoreInterval,
                FileStoragePath: flags.Server.FileStoragePath,
                Restore:         flags.Server.Restore,
                Database: DatabaseConfig{
                        DSN:            flags.Database.DSN,
                        MigrationsPath: flags.Database.MigrationsPath,
                },
                GRPC: GRPCConfig{
                        Addr:    flags.GRPC.Addr,
                        Enabled: flags.GRPC.Enabled,
                        MaxConn: flags.GRPC.MaxConn,
                        Timeout: flags.GRPC.Timeout,
                },
                PrivateKey:    flags.PrivateKey,
                EnablePprof:   flags.Server.EnablePprof,
                ConfigFile:    flags.ConfigFile,
                TrustedSubnet: flags.Server.TrustedSubnet,
        }

        // Load private key for decryption if provided
        if flags.CryptoKey != "" </span><span class="cov0" title="0">{
                var err error
                cfg.PrivateRSAKey, err = crypto.LoadPrivateKey(flags.CryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("failed to load private key", "error", err, "path", flags.CryptoKey)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">slog.Info("loaded private key for decryption", "path", flags.CryptoKey)</span>
        }

        <span class="cov8" title="1">return cfg</span>
}

// IsStoreEnabled возвращает true, если включено сохранение метрик на сервере.
func (cfg *Config) IsStoreEnabled() bool <span class="cov8" title="1">{
        return cfg.FileStoragePath != ""
}</span>

// IsRestoreEnabled надо ли восстанавливать метрики из файла при старте.
func (cfg *Config) IsRestoreEnabled() bool <span class="cov8" title="1">{
        return cfg.Restore &amp;&amp; cfg.IsStoreEnabled()
}</span>

// GetStorePath возвращает путь к файлу для сохранения метрик.
func (cfg *Config) GetStorePath() string <span class="cov8" title="1">{
        return cfg.FileStoragePath
}</span>

// IsSyncStore сохранение метрик на сервере синхронно (сразу после изменения, если нулевой интервал).
func (cfg *Config) IsSyncStore() bool <span class="cov8" title="1">{
        return cfg.StoreInterval == 0
}</span>

// GetStoreInterval возвращает интервал сохранения метрик на сервере в секундах.
func (cfg *Config) GetStoreInterval() int <span class="cov8" title="1">{
        return cfg.StoreInterval
}</span>

// IsDatabaseEnabled возвращает true, если переданы параметры подключения к БД.
func (cfg *Config) IsDatabaseEnabled() bool <span class="cov8" title="1">{
        return cfg.Database.DSN != ""
}</span>

// IsRequestSigningEnabled включена ли проверка подписи метрик.
func (cfg *Config) IsRequestSigningEnabled() bool <span class="cov8" title="1">{
        return cfg.PrivateKey != ""
}</span>

// IsEncryptionEnabled возвращает true, если включено шифрование.
func (cfg *Config) IsEncryptionEnabled() bool <span class="cov8" title="1">{
        return cfg.PrivateRSAKey != nil
}</span>

// IsTrustedSubnetEnabled возвращает true, если указана доверенная подсеть.
func (cfg *Config) IsTrustedSubnetEnabled() bool <span class="cov0" title="0">{
        return cfg.TrustedSubnet != ""
}</span>

// IsGRPCEnabled возвращает true, если включен gRPC сервер.
func (cfg *Config) IsGRPCEnabled() bool <span class="cov0" title="0">{
        return cfg.GRPC.Enabled
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package app реализует основную логику работы HTTP-сервера.
package app

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "time"
)

const (
        defaultServerAddr      = "localhost:8080"
        defaultFileStoragePath = "/tmp/metrics-db.json"
)

// ErrConfigFileNotSpecified возвращается, когда путь к файлу конфигурации не указан.
var ErrConfigFileNotSpecified = errors.New("config file path not specified")

// DefaultServerAddr возвращает адрес сервера по умолчанию.
func DefaultServerAddr() string <span class="cov8" title="1">{
        return defaultServerAddr
}</span>

// DefaultStoreInterval возвращает интервал сохранения метрик по умолчанию.
func DefaultStoreInterval() int <span class="cov8" title="1">{
        return defaultStoreInterval
}</span>

// DefaultFileStoragePath возвращает путь к файлу хранения метрик по умолчанию.
func DefaultFileStoragePath() string <span class="cov8" title="1">{
        return defaultFileStoragePath
}</span>

// JSONConfig представляет структуру конфигурационного файла сервера в формате JSON.
type JSONConfig struct {
        Address       string `json:"address"`        // Адрес и порт сервера
        Restore       bool   `json:"restore"`        // Восстанавливать метрики из файла при старте
        StoreInterval string `json:"store_interval"` // Интервал сохранения метрик в виде строки (например, "1s")
        StoreFile     string `json:"store_file"`     // Путь к файлу для хранения метрик
        DatabaseDSN   string `json:"database_dsn"`   // Строка подключения к базе данных
        CryptoKey     string `json:"crypto_key"`     // Путь к файлу с приватным ключом для расшифровки
        EnablePprof   bool   `json:"enable_pprof"`   // Включить профилирование через pprof
        TrustedSubnet string `json:"trusted_subnet"` // CIDR доверенной подсети для проверки IP-адресов агентов
        GRPCAddress   string `json:"grpc_address"`   // Адрес и порт для gRPC сервера
        GRPCEnabled   bool   `json:"grpc_enabled"`   // Включить gRPC сервер
        GRPCMaxConn   int    `json:"grpc_max_conn"`  // Максимальное количество одновременных соединений для gRPC сервера
        GRPCTimeout   int    `json:"grpc_timeout"`   // Таймаут для gRPC запросов в секундах
}

// LoadJSONConfig загружает конфигурацию из JSON-файла.
// Возвращает ErrConfigFileNotSpecified, если файл не указан.
func LoadJSONConfig(filePath string) (*JSONConfig, error) <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return nil, ErrConfigFileNotSpecified
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config JSONConfig
        jsonErr := json.Unmarshal(data, &amp;config)
        if jsonErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", jsonErr)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// ApplyJSONConfig применяет настройки из JSON-конфигурации к флагам.
// Настройки из JSON имеют более низкий приоритет, чем флаги командной строки и переменные окружения.
func ApplyJSONConfig(flags *Flags, jsonConfig *JSONConfig) error <span class="cov8" title="1">{
        if jsonConfig == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Применяем настройки по категориям
        <span class="cov8" title="1">if err := applyServerConfig(flags, jsonConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">applyDatabaseConfig(flags, jsonConfig)
        applySecurityConfig(flags, jsonConfig)
        applyGRPCConfig(flags, jsonConfig)

        return nil</span>
}

// applyServerConfig применяет настройки сервера из JSON-конфигурации.
func applyServerConfig(flags *Flags, jsonConfig *JSONConfig) error <span class="cov8" title="1">{
        // Адрес сервера
        if flags.Server.Addr == defaultServerAddr &amp;&amp; jsonConfig.Address != "" </span><span class="cov8" title="1">{
                flags.Server.Addr = jsonConfig.Address
        }</span>

        // Интервал сохранения метрик
        <span class="cov8" title="1">if flags.Server.StoreInterval == defaultStoreInterval &amp;&amp; jsonConfig.StoreInterval != "" </span><span class="cov8" title="1">{
                duration, durationErr := time.ParseDuration(jsonConfig.StoreInterval)
                if durationErr != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid store_interval in config: %w", durationErr)
                }</span>
                <span class="cov8" title="1">flags.Server.StoreInterval = int(duration.Seconds())</span>
        }

        // Путь к файлу для хранения метрик
        <span class="cov8" title="1">if flags.Server.FileStoragePath == defaultFileStoragePath &amp;&amp; jsonConfig.StoreFile != "" </span><span class="cov8" title="1">{
                flags.Server.FileStoragePath = jsonConfig.StoreFile
        }</span>

        // Восстанавливать метрики из файла при старте
        <span class="cov8" title="1">if flags.Server.Restore &amp;&amp; !jsonConfig.Restore </span><span class="cov8" title="1">{
                flags.Server.Restore = jsonConfig.Restore
        }</span>

        // Включить профилирование через pprof
        <span class="cov8" title="1">if !flags.Server.EnablePprof &amp;&amp; jsonConfig.EnablePprof </span><span class="cov8" title="1">{
                flags.Server.EnablePprof = jsonConfig.EnablePprof
        }</span>

        // Доверенная подсеть
        <span class="cov8" title="1">if flags.Server.TrustedSubnet == "" &amp;&amp; jsonConfig.TrustedSubnet != "" </span><span class="cov0" title="0">{
                flags.Server.TrustedSubnet = jsonConfig.TrustedSubnet
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// applyDatabaseConfig применяет настройки базы данных из JSON-конфигурации.
func applyDatabaseConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        // Строка подключения к базе данных
        if flags.Database.DSN == "" &amp;&amp; jsonConfig.DatabaseDSN != "" </span><span class="cov8" title="1">{
                flags.Database.DSN = jsonConfig.DatabaseDSN
        }</span>
}

// applySecurityConfig применяет настройки безопасности из JSON-конфигурации.
func applySecurityConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        // Путь к файлу с приватным ключом для расшифровки
        if flags.CryptoKey == "" &amp;&amp; jsonConfig.CryptoKey != "" </span><span class="cov8" title="1">{
                flags.CryptoKey = jsonConfig.CryptoKey
        }</span>
}

// applyGRPCConfig применяет настройки gRPC из JSON-конфигурации.
func applyGRPCConfig(flags *Flags, jsonConfig *JSONConfig) <span class="cov8" title="1">{
        // Адрес и порт для gRPC сервера
        if flags.GRPC.Addr == defaultGRPCAddr &amp;&amp; jsonConfig.GRPCAddress != "" </span><span class="cov0" title="0">{
                flags.GRPC.Addr = jsonConfig.GRPCAddress
        }</span>

        // Включить gRPC сервер
        <span class="cov8" title="1">if !flags.GRPC.Enabled &amp;&amp; jsonConfig.GRPCEnabled </span><span class="cov0" title="0">{
                flags.GRPC.Enabled = jsonConfig.GRPCEnabled
        }</span>

        // Максимальное количество одновременных соединений для gRPC сервера
        <span class="cov8" title="1">if flags.GRPC.MaxConn == defaultGRPCMaxConn &amp;&amp; jsonConfig.GRPCMaxConn &gt; 0 </span><span class="cov0" title="0">{
                flags.GRPC.MaxConn = jsonConfig.GRPCMaxConn
        }</span>

        // Таймаут для gRPC запросов в секундах
        <span class="cov8" title="1">if flags.GRPC.Timeout == defaultGRPCTimeout &amp;&amp; jsonConfig.GRPCTimeout &gt; 0 </span><span class="cov0" title="0">{
                flags.GRPC.Timeout = jsonConfig.GRPCTimeout
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package app

import (
        "errors"
        "flag"
        "os"
        "strconv"
)

const (
        defaultStoreInterval = 300
        defaultGRPCAddr      = "localhost:9090"
        defaultGRPCMaxConn   = 100
        defaultGRPCTimeout   = 5
)

// Flags содержит все флаги сервера.
type Flags struct {
        Server struct {
                Addr string
                // Интервал сохранения метрик на сервере в секундах
                StoreInterval int
                // Полное имя файла, в который будут сохранены метрики
                FileStoragePath string
                // Загружать или нет ранее сохраненные метрики из файла
                Restore bool
                // Включить профилирование через pprof
                EnablePprof bool
                // CIDR доверенной подсети для проверки IP-адресов агентов
                TrustedSubnet string
        }

        Database struct {
                // Параметры подключения к БД, например postgres://username:password@localhost:5432/database_name
                DSN string
                // Путь к директории с миграциями
                MigrationsPath string
        }

        GRPC struct {
                // Адрес и порт для gRPC сервера
                Addr string
                // Включен ли gRPC сервер
                Enabled bool
                // Максимальное количество одновременных соединений
                MaxConn int
                // Таймаут для gRPC запросов в секундах
                Timeout int
        }

        PrivateKey string
        CryptoKey  string // Path to the private key file for decryption
        ConfigFile string // Путь к файлу конфигурации в формате JSON
}

// ParseFlags обрабатывает аргументы командной строки
// и сохраняет их значения в соответствующих переменных.
func ParseFlags() (*Flags, error) <span class="cov8" title="1">{
        flags := Flags{}

        // Регистрируем флаги командной строки
        registerCommandLineFlags(&amp;flags)

        // Парсим переданные серверу аргументы в зарегистрированные переменные.
        flag.Parse()

        // Применяем переменные окружения
        if err := applyEnvironmentVariables(&amp;flags); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Загружаем и применяем JSON-конфигурацию
        <span class="cov8" title="1">if err := loadAndApplyJSONConfig(&amp;flags); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;flags, nil</span>
}

// registerCommandLineFlags регистрирует флаги командной строки.
func registerCommandLineFlags(flags *Flags) <span class="cov8" title="1">{
        // Регистрируем переменную flagRunAddr как аргумент -a со значением ":8080" по умолчанию.
        flag.StringVar(
                &amp;flags.Server.Addr,
                "a",
                defaultServerAddr,
                "IP  адрес и порт на которых следует запустить сервер",
        )
        // Регистрируем переменную flagStoreInterval как аргумент -i со значением 300 по умолчанию.
        flag.IntVar(
                &amp;flags.Server.StoreInterval,
                "i",
                defaultStoreInterval,
                "Интервал сохранения метрик на диск, в секундах",
        )
        // Регистрируем переменную flagFileStoragePath как аргумент -f со значением metrics.json по умолчанию.
        flag.StringVar(
                &amp;flags.Server.FileStoragePath,
                "f",
                defaultFileStoragePath,
                "Путь к файлу для хранения метрик",
        )
        // Регистрируем переменную flagRestore как аргумент -r со значением false по умолчанию.
        flag.BoolVar(&amp;flags.Server.Restore, "r", true, "Восстанавливать метрики из файла при старте?")

        // Добавляем флаг профилирования
        flag.BoolVar(
                &amp;flags.Server.EnablePprof,
                "pprof",
                false,
                "enable pprof profiling with /debug/pprof routes",
        )

        // Адрес подключения к БД PostgresSQL, по умолчанию пустое значение (не подключаемся к БД).
        flag.StringVar(
                &amp;flags.Database.DSN,
                "d",
                "",
                "Параметры подключения к базе данных Postgres, формат: postgres://user:password@localhost:5432/database",
        )
        // Путь к директории с миграциями относительно корня проекта, по умолчанию "migrations/server".
        flag.StringVar(&amp;flags.Database.MigrationsPath,
                "migrations-path",
                "migrations/server",
                "Путь к директории с миграциями")

        flag.StringVar(&amp;flags.PrivateKey, "k", "", "Приватный ключ для подписи запросов к серверу")
        flag.StringVar(
                &amp;flags.CryptoKey,
                "crypto-key",
                "",
                "Путь к файлу с приватным ключом для расшифровки",
        )

        // Добавляем флаг для пути к файлу конфигурации
        flag.StringVar(&amp;flags.ConfigFile, "c", "", "Путь к файлу конфигурации в формате JSON")
        flag.StringVar(&amp;flags.ConfigFile, "config", "", "Путь к файлу конфигурации в формате JSON")

        // Добавляем флаг для доверенной подсети
        flag.StringVar(
                &amp;flags.Server.TrustedSubnet,
                "t",
                "",
                "CIDR доверенной подсети для проверки IP-адресов агентов",
        )

        // Добавляем флаги для gRPC
        flag.StringVar(
                &amp;flags.GRPC.Addr,
                "grpc-address",
                defaultGRPCAddr,
                "Адрес и порт для gRPC сервера",
        )
        flag.BoolVar(
                &amp;flags.GRPC.Enabled,
                "grpc-enabled",
                false,
                "Включить gRPC сервер",
        )
        flag.IntVar(
                &amp;flags.GRPC.MaxConn,
                "grpc-max-conn",
                defaultGRPCMaxConn,
                "Максимальное количество одновременных соединений для gRPC сервера",
        )
        flag.IntVar(
                &amp;flags.GRPC.Timeout,
                "grpc-timeout",
                defaultGRPCTimeout,
                "Таймаут для gRPC запросов в секундах",
        )
}</span>

// applyEnvironmentVariables применяет переменные окружения к флагам.
func applyEnvironmentVariables(flags *Flags) error <span class="cov8" title="1">{
        // Применяем переменные окружения по категориям
        if err := applyServerEnvVars(flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">applyDatabaseEnvVars(flags)
        applySecurityEnvVars(flags)
        applyConfigEnvVars(flags)
        if err := applyGRPCEnvVars(flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// applyServerEnvVars применяет переменные окружения для настроек сервера.
func applyServerEnvVars(flags *Flags) error <span class="cov8" title="1">{
        // Для случаев, когда в переменной окружения ADDRESS присутствует непустое значение,
        // переопределим адрес запуска сервера,
        // даже если он был передан через аргумент командной строки.
        if envRunAddr := os.Getenv("ADDRESS"); envRunAddr != "" </span><span class="cov0" title="0">{
                flags.Server.Addr = envRunAddr
        }</span>
        <span class="cov8" title="1">if envStoreInterval := os.Getenv("STORE_INTERVAL"); envStoreInterval != "" </span><span class="cov0" title="0">{
                storeInterval, err := strconv.Atoi(envStoreInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags.Server.StoreInterval = storeInterval</span>
        }
        // Если переменная окружения FILE_STORAGE_PATH присутствует (даже
        // пустая), переопределим путь к файлу хранения метрик.
        <span class="cov8" title="1">if envFileStoragePath, ok := os.LookupEnv("FILE_STORAGE_PATH"); ok </span><span class="cov0" title="0">{
                flags.Server.FileStoragePath = envFileStoragePath
        }</span>
        // Если переменная окружения RESTORE присутствует (даже пустая), переопределим флаг восстановления метрик из файла.
        <span class="cov8" title="1">if envRestore, ok := os.LookupEnv("RESTORE"); ok </span><span class="cov0" title="0">{
                restore, err := strconv.ParseBool(envRestore)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags.Server.Restore = restore</span>
        }

        // Если передана доверенная подсеть в параметрах окружения, используем её
        <span class="cov8" title="1">if envTrustedSubnet, ok := os.LookupEnv("TRUSTED_SUBNET"); ok </span><span class="cov0" title="0">{
                flags.Server.TrustedSubnet = envTrustedSubnet
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// applyDatabaseEnvVars применяет переменные окружения для настроек базы данных.
func applyDatabaseEnvVars(flags *Flags) <span class="cov8" title="1">{
        // Если переданы параметры БД в параметрах окружения, используем их
        if envDatabaseDSN, ok := os.LookupEnv("DATABASE_DSN"); ok </span><span class="cov0" title="0">{
                flags.Database.DSN = envDatabaseDSN
        }</span>
}

// applySecurityEnvVars применяет переменные окружения для настроек безопасности.
func applySecurityEnvVars(flags *Flags) <span class="cov8" title="1">{
        // Если передан ключ в параметрах окружения, используем его
        if envPrivateKey, ok := os.LookupEnv("KEY"); ok </span><span class="cov0" title="0">{
                flags.PrivateKey = envPrivateKey
        }</span>

        // Если передан путь к файлу с приватным ключом в параметрах окружения, используем его
        <span class="cov8" title="1">if envCryptoKey, ok := os.LookupEnv("CRYPTO_KEY"); ok </span><span class="cov0" title="0">{
                flags.CryptoKey = envCryptoKey
        }</span>
}

// applyConfigEnvVars применяет переменные окружения для настроек конфигурации.
func applyConfigEnvVars(flags *Flags) <span class="cov8" title="1">{
        // Если передан путь к файлу конфигурации в параметрах окружения, используем его
        if envConfigFile, ok := os.LookupEnv("CONFIG"); ok </span><span class="cov0" title="0">{
                flags.ConfigFile = envConfigFile
        }</span>
}

// applyGRPCEnvVars применяет переменные окружения для настроек gRPC.
func applyGRPCEnvVars(flags *Flags) error <span class="cov8" title="1">{
        // Обработка переменных окружения для gRPC
        if envGRPCAddr, ok := os.LookupEnv("GRPC_ADDRESS"); ok </span><span class="cov0" title="0">{
                flags.GRPC.Addr = envGRPCAddr
        }</span>
        <span class="cov8" title="1">if envGRPCEnabled, ok := os.LookupEnv("GRPC_ENABLED"); ok </span><span class="cov0" title="0">{
                enabled, err := strconv.ParseBool(envGRPCEnabled)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags.GRPC.Enabled = enabled</span>
        }
        <span class="cov8" title="1">if envGRPCMaxConn, ok := os.LookupEnv("GRPC_MAX_CONN"); ok </span><span class="cov0" title="0">{
                maxConn, err := strconv.Atoi(envGRPCMaxConn)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags.GRPC.MaxConn = maxConn</span>
        }
        <span class="cov8" title="1">if envGRPCTimeout, ok := os.LookupEnv("GRPC_TIMEOUT"); ok </span><span class="cov0" title="0">{
                timeout, err := strconv.Atoi(envGRPCTimeout)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags.GRPC.Timeout = timeout</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// loadAndApplyJSONConfig загружает и применяет JSON-конфигурацию.
func loadAndApplyJSONConfig(flags *Flags) error <span class="cov8" title="1">{
        // Загружаем конфигурацию из JSON-файла, если он указан
        jsonConfig, loadErr := LoadJSONConfig(flags.ConfigFile)
        if loadErr != nil </span><span class="cov8" title="1">{
                // Если файл конфигурации не указан, это не ошибка
                if errors.Is(loadErr, ErrConfigFileNotSpecified) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return loadErr</span>
        }

        // Применяем настройки из JSON-конфигурации (с более низким приоритетом)
        <span class="cov0" title="0">return ApplyJSONConfig(flags, jsonConfig)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package grpc

import (
        "context"
        "errors"
        "fmt"
        "io"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/grpc/pb"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
)

// MetricsService реализует интерфейс MetricsServiceServer из прото-файла.
type MetricsService struct {
        pb.UnimplementedMetricsServiceServer
        log     *zap.Logger
        cfg     *app.Config
        storage storage.Repository
}

// NewMetricsService создает новый сервис метрик для gRPC.
func NewMetricsService(
        log *zap.Logger,
        cfg *app.Config,
        storage storage.Repository,
) *MetricsService <span class="cov0" title="0">{
        return &amp;MetricsService{
                log:     log,
                cfg:     cfg,
                storage: storage,
        }
}</span>

// Update обрабатывает запрос на обновление одной метрики.
func (s *MetricsService) Update(
        ctx context.Context,
        req *pb.UpdateRequest,
) (*pb.MetricResponse, error) <span class="cov0" title="0">{
        if req == nil || req.GetMetric() == nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "metric is required")
        }</span>

        // Преобразуем метрику из protobuf в доменную модель
        <span class="cov0" title="0">metric, err := s.protoToMetric(req.GetMetric())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid metric: %v", err)
        }</span>

        // Сохраняем метрику в хранилище
        <span class="cov0" title="0">updateErr := s.storage.UpdateMetric(ctx, *metric)
        if updateErr != nil </span><span class="cov0" title="0">{
                s.log.Error(
                        "failed to update metric",
                        zap.Error(updateErr),
                        zap.String("name", metric.Name),
                )
                return nil, status.Errorf(codes.Internal, "failed to update metric: %v", updateErr)
        }</span>

        <span class="cov0" title="0">s.log.Debug("metric updated via gRPC",
                zap.String("name", metric.Name),
                zap.String("type", string(metric.MType)))

        // Преобразуем метрику из доменной модели обратно в protobuf
        response := &amp;pb.MetricResponse{
                Metric: req.GetMetric(), // отправляем обратно полученную метрику
        }

        return response, nil</span>
}

// UpdateBatch обрабатывает запрос на пакетное обновление метрик.
func (s *MetricsService) UpdateBatch(
        ctx context.Context,
        req *pb.UpdateBatchRequest,
) (*pb.UpdateBatchResponse, error) <span class="cov0" title="0">{
        if req == nil || len(req.GetMetrics()) == 0 </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "metrics are required")
        }</span>

        // Преобразуем метрики из protobuf в доменную модель
        <span class="cov0" title="0">metricsToUpdate := make([]metrics.Metric, 0, len(req.GetMetrics()))
        for _, protoMetric := range req.GetMetrics() </span><span class="cov0" title="0">{
                metric, err := s.protoToMetric(protoMetric)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("invalid metric", zap.Error(err), zap.String("name", protoMetric.GetName()))
                        continue</span> // Пропускаем невалидные метрики
                }
                <span class="cov0" title="0">metricsToUpdate = append(metricsToUpdate, *metric)</span>
        }

        // Если все метрики оказались невалидными
        <span class="cov0" title="0">if len(metricsToUpdate) == 0 </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "no valid metrics provided")
        }</span>

        // Сохраняем метрики в хранилище
        <span class="cov0" title="0">if err := s.storage.UpdateMetrics(ctx, metricsToUpdate); err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to update metrics batch", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to update metrics batch: %v", err)
        }</span>

        <span class="cov0" title="0">s.log.Debug("metrics batch updated via gRPC", zap.Int("count", len(metricsToUpdate)))

        return &amp;pb.UpdateBatchResponse{
                Success: true,
        }, nil</span>
}

// GetValue получает значение метрики по имени и типу.
func (s *MetricsService) GetValue(
        ctx context.Context,
        req *pb.GetValueRequest,
) (*pb.MetricResponse, error) <span class="cov0" title="0">{
        if req == nil || req.GetName() == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "metric name is required")
        }</span>

        // Преобразуем тип метрики из protobuf в доменную модель
        <span class="cov0" title="0">var metricType metrics.MetricType
        switch req.GetType() </span>{
        case pb.MetricType_GAUGE:<span class="cov0" title="0">
                metricType = metrics.TypeGauge</span>
        case pb.MetricType_COUNTER:<span class="cov0" title="0">
                metricType = metrics.TypeCounter</span>
        default:<span class="cov0" title="0">
                return nil, status.Errorf(codes.InvalidArgument, "invalid metric type")</span>
        }

        // Получаем метрику из хранилища
        <span class="cov0" title="0">metric, found := s.storage.GetMetric(ctx, metricType, req.GetName())
        if !found </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.NotFound, "metric not found")
        }</span>

        // Преобразуем метрику из доменной модели в protobuf
        <span class="cov0" title="0">protoMetric := s.metricToProto(&amp;metric)

        return &amp;pb.MetricResponse{
                Metric: protoMetric,
        }, nil</span>
}

// Ping проверяет соединение с базой данных.
func (s *MetricsService) Ping(ctx context.Context, _ *pb.PingRequest) (*pb.PingResponse, error) <span class="cov0" title="0">{
        // Проверяем, включена ли база данных
        if !s.cfg.IsDatabaseEnabled() </span><span class="cov0" title="0">{
                return &amp;pb.PingResponse{
                        Success: false,
                        Error:   "database not configured",
                }, nil
        }</span>

        // Для проверки соединения с базой данных не используем Ping, так как его нет в интерфейсе
        // Вместо этого просто попробуем получить количество метрик
        <span class="cov0" title="0">_ = s.storage.Count(ctx)

        return &amp;pb.PingResponse{
                Success: true,
        }, nil</span>
}

// StreamMetrics обрабатывает потоковую отправку метрик от клиента.
func (s *MetricsService) StreamMetrics(stream pb.MetricsService_StreamMetricsServer) error <span class="cov0" title="0">{
        ctx := stream.Context()
        // Создаем буфер для метрик
        var metricsBuffer []metrics.Metric

        // Обрабатываем поток метрик
        for </span><span class="cov0" title="0">{
                // Получаем метрику из потока
                protoMetric, err := stream.Recv()
                if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        // Конец потока, сохраняем накопленные метрики
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("error receiving stream", zap.Error(err))
                        return status.Errorf(codes.Internal, "failed to receive metric: %v", err)
                }</span>

                // Преобразуем метрику из protobuf в доменную модель
                <span class="cov0" title="0">metric, err := s.protoToMetric(protoMetric)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error(
                                "invalid metric in stream",
                                zap.Error(err),
                                zap.String("name", protoMetric.GetName()),
                        )
                        continue</span> // Пропускаем невалидные метрики
                }

                // Добавляем метрику в буфер
                <span class="cov0" title="0">metricsBuffer = append(metricsBuffer, *metric)

                // Если буфер достиг определенного размера, сохраняем метрики
                // Это позволяет сократить количество обращений к хранилищу
                const maxBufferSize = 100
                if len(metricsBuffer) &gt;= maxBufferSize </span><span class="cov0" title="0">{
                        saveErr := s.saveMetricsBuffer(ctx, metricsBuffer)
                        if saveErr != nil </span><span class="cov0" title="0">{
                                return status.Errorf(codes.Internal, "failed to save metrics batch: %v", saveErr)
                        }</span>
                        <span class="cov0" title="0">metricsBuffer = nil</span> // Очищаем буфер
                }
        }

        // Сохраняем оставшиеся метрики
        <span class="cov0" title="0">if len(metricsBuffer) &gt; 0 </span><span class="cov0" title="0">{
                saveErr := s.saveMetricsBuffer(ctx, metricsBuffer)
                if saveErr != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Internal, "failed to save metrics batch: %v", saveErr)
                }</span>
        }

        // Отправляем ответ клиенту
        <span class="cov0" title="0">return stream.SendAndClose(&amp;pb.UpdateBatchResponse{
                Success: true,
        })</span>
}

// saveMetricsBuffer сохраняет буфер метрик в хранилище.
func (s *MetricsService) saveMetricsBuffer(
        ctx context.Context,
        metricsBuffer []metrics.Metric,
) error <span class="cov0" title="0">{
        if len(metricsBuffer) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s.log.Debug("saving metrics from stream buffer", zap.Int("count", len(metricsBuffer)))

        // Сохраняем метрики в хранилище
        if err := s.storage.UpdateMetrics(ctx, metricsBuffer); err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to update metrics batch from stream", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// protoToMetric преобразует метрику из protobuf в доменную модель.
func (s *MetricsService) protoToMetric(protoMetric *pb.Metric) (*metrics.Metric, error) <span class="cov0" title="0">{
        if protoMetric == nil </span><span class="cov0" title="0">{
                return nil, errors.New("metric is nil")
        }</span>

        // Проверяем тип метрики
        <span class="cov0" title="0">switch protoMetric.GetType() </span>{
        case pb.MetricType_GAUGE:<span class="cov0" title="0">
                if protoMetric.Value == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("gauge value is required")
                }</span>
                <span class="cov0" title="0">return metrics.NewGauge(protoMetric.GetName(), protoMetric.GetValue()), nil</span>
        case pb.MetricType_COUNTER:<span class="cov0" title="0">
                if protoMetric.Delta == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("counter delta is required")
                }</span>
                <span class="cov0" title="0">return metrics.NewCounter(protoMetric.GetName(), protoMetric.GetDelta()), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown metric type: %v", protoMetric.GetType())</span>
        }
}

// metricToProto преобразует метрику из доменной модели в protobuf.
func (s *MetricsService) metricToProto(metric *metrics.Metric) *pb.Metric <span class="cov0" title="0">{
        protoMetric := &amp;pb.Metric{
                Name: metric.Name,
        }

        switch metric.MType </span>{
        case metrics.TypeGauge:<span class="cov0" title="0">
                value := *metric.Value
                protoMetric.Type = pb.MetricType_GAUGE
                protoMetric.Value = &amp;value</span>
        case metrics.TypeCounter:<span class="cov0" title="0">
                delta := *metric.Delta
                protoMetric.Type = pb.MetricType_COUNTER
                protoMetric.Delta = &amp;delta</span>
        }

        <span class="cov0" title="0">return protoMetric</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package grpc реализует gRPC-сервер для сбора метрик.
package grpc

import (
        "fmt"
        "net"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/keepalive"

        "github.com/maynagashev/go-metrics/internal/grpc/pb"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
)

// Константы для параметров keepalive.
const (
        // Keepalive enforcement policy.
        MinPingTime         = 5 * time.Second // минимальное время между ping от клиента
        PermitWithoutStream = true            // разрешить keepalive без активных потоков

        // Keepalive server parameters.
        MaxConnectionIdleTime     = 15 * time.Second // максимальное время простоя соединения
        MaxConnectionAgeTime      = 30 * time.Second // максимальное время жизни соединения
        MaxConnectionAgeGraceTime = 5 * time.Second  // grace период перед принудительным закрытием
        PingTime                  = 5 * time.Second  // интервал для ping от сервера
        PingTimeout               = 1 * time.Second  // таймаут для ping

        // Default maximum number of concurrent streams.
        DefaultMaxConcurrentStreams uint32 = 100 // значение по умолчанию для максимального количества одновременных потоков
)

// Server представляет gRPC сервер.
type Server struct {
        cfg         *app.Config
        log         *zap.Logger
        storage     storage.Repository
        grpcServer  *grpc.Server
        metricsServ *MetricsService
}

// New создает новый экземпляр gRPC сервера.
func New(log *zap.Logger, cfg *app.Config, storage storage.Repository) *Server <span class="cov0" title="0">{
        metricsService := NewMetricsService(log, cfg, storage)

        return &amp;Server{
                cfg:         cfg,
                log:         log,
                storage:     storage,
                metricsServ: metricsService,
        }
}</span>

// Start запускает gRPC сервер.
func (s *Server) Start() error <span class="cov0" title="0">{
        // Проверяем, включен ли gRPC
        if !s.cfg.IsGRPCEnabled() </span><span class="cov0" title="0">{
                s.log.Info("gRPC server disabled, skip start")
                return nil
        }</span>

        // Создаем слушатель TCP
        <span class="cov0" title="0">addr := s.cfg.GRPC.Addr
        s.log.Info("starting gRPC server", zap.String("address", addr))
        lis, err := net.Listen("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %w", err)
        }</span>

        // Создаем параметры keepalive
        <span class="cov0" title="0">kaep := keepalive.EnforcementPolicy{
                MinTime:             MinPingTime,
                PermitWithoutStream: PermitWithoutStream,
        }

        kasp := keepalive.ServerParameters{
                MaxConnectionIdle:     MaxConnectionIdleTime,
                MaxConnectionAge:      MaxConnectionAgeTime,
                MaxConnectionAgeGrace: MaxConnectionAgeGraceTime,
                Time:                  PingTime,
                Timeout:               PingTimeout,
        }

        // Определяем максимальное количество одновременных потоков
        maxConnections := DefaultMaxConcurrentStreams

        // Безопасное использование значения из конфигурации, если оно положительное и в пределах uint32
        if s.cfg.GRPC.MaxConn &gt; 0 &amp;&amp; s.cfg.GRPC.MaxConn &lt;= int(DefaultMaxConcurrentStreams) </span><span class="cov0" title="0">{
                // Просто копируем значение - безопасно, т.к. уже проверили, что значение в допустимых пределах
                //nolint:gosec // G115: проверка на допустимые значения выполнена выше
                maxConnections = uint32(s.cfg.GRPC.MaxConn)
        }</span> else<span class="cov0" title="0"> if s.cfg.GRPC.MaxConn &gt; int(DefaultMaxConcurrentStreams) </span><span class="cov0" title="0">{
                s.log.Warn("MaxConn value exceeds safe limit, using default",
                        zap.Int("configured", s.cfg.GRPC.MaxConn),
                        zap.Uint32("using", DefaultMaxConcurrentStreams))
        }</span>

        // Настраиваем опции сервера
        <span class="cov0" title="0">opts := []grpc.ServerOption{
                grpc.KeepaliveEnforcementPolicy(kaep),
                grpc.KeepaliveParams(kasp),
                grpc.MaxConcurrentStreams(maxConnections),
        }

        // Создаем gRPC сервер
        s.grpcServer = grpc.NewServer(opts...)

        // Регистрируем сервис метрик
        pb.RegisterMetricsServiceServer(s.grpcServer, s.metricsServ)

        // Запускаем сервер в отдельной горутине
        go func() </span><span class="cov0" title="0">{
                serveErr := s.grpcServer.Serve(lis)
                if serveErr != nil </span><span class="cov0" title="0">{
                        s.log.Error("failed to serve gRPC", zap.Error(serveErr))
                }</span>
        }()

        <span class="cov0" title="0">s.log.Info("gRPC server started", zap.String("address", addr))
        return nil</span>
}

// Stop останавливает gRPC сервер.
func (s *Server) Stop() <span class="cov0" title="0">{
        if s.grpcServer != nil </span><span class="cov0" title="0">{
                s.log.Info("stopping gRPC server")
                s.grpcServer.GracefulStop()
                s.log.Info("gRPC server stopped")
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package grpc

import (
        "context"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
)

// ServerWrapper представляет обертку для gRPC сервера.
// Эта обертка будет использоваться для запуска gRPC сервера
// в контексте HTTP-сервера.
type ServerWrapper struct {
        server *Server
        log    *zap.Logger
        cfg    *app.Config
}

// NewServer создает новый экземпляр обертки gRPC сервера.
func NewServer(log *zap.Logger, cfg *app.Config, storage storage.Repository) *ServerWrapper <span class="cov0" title="0">{
        return &amp;ServerWrapper{
                server: New(log, cfg, storage),
                log:    log,
                cfg:    cfg,
        }
}</span>

// Start запускает gRPC сервер в отдельной горутине.
func (w *ServerWrapper) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Проверяем, включен ли gRPC сервер
        if !w.cfg.IsGRPCEnabled() </span><span class="cov0" title="0">{
                w.log.Info("gRPC server is disabled, skipping start")
                return nil
        }</span>

        // Запускаем gRPC сервер
        <span class="cov0" title="0">if err := w.server.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // В отдельной горутине ожидаем завершения контекста для graceful shutdown
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                w.log.Info("context done, stopping gRPC server")
                w.server.Stop()
        }</span>()

        <span class="cov0" title="0">return nil</span>
}

// Stop останавливает gRPC сервер.
func (w *ServerWrapper) Stop() <span class="cov0" title="0">{
        if w.server != nil </span><span class="cov0" title="0">{
                w.server.Stop()
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package index реализует обработчик для получения списка всех метрик в формате JSON.
// Предоставляет эндпоинт для получения текущего состояния всех метрик в системе.
package index

import (
        "encoding/json"
        "net/http"

        "github.com/maynagashev/go-metrics/internal/server/storage"
)

// New возвращает http.HandlerFunc, который отдает список метрик на сервере.
func New(st storage.Repository) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")

                // Возвращаем метрики в формате JSON архива
                metrics := st.GetMetrics(r.Context())
                jsonData, err := json.Marshal(metrics)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">_, err = w.Write(jsonData)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package ping реализует обработчик для проверки соединения с базой данных.
// Предоставляет эндпоинт для проверки работоспособности системы.
package ping

import (
        "context"
        "errors"
        "net/http"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage/pgstorage"
        "github.com/maynagashev/go-metrics/pkg/response"
)

type Response struct {
        response.Response
}

type Storage interface {
        GetMetrics(ctx context.Context) []metrics.Metric
}

// Handle логика обработчика ping с указанной базой данных, чтобы можно было провести тестирование моком.
func Handle(storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")

                // Проверяем подключение сделав запрос к базе данных.
                _ = storage.GetMetrics(r.Context())

                response.OK(w, "pong")
        }</span>
}

// New создает подключение к базе данных из конфига и возвращает обработчик запроса.
func New(config *app.Config, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        // Если не используется PostgreSQL, то возвращаем обработчик, который возвращает ошибку.
        if !config.IsDatabaseEnabled() </span><span class="cov8" title="1">{
                return func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                        response.Error(w, errors.New("не указана база данных"), http.StatusInternalServerError)
                }</span>
        }

        // Создаем экземпляр хранилища на основе PostgreSQL, здесь создается подключение и накатываются миграции.
        <span class="cov8" title="1">db, err := pgstorage.New(context.Background(), config, log)
        // Если не удалось создать хранилище, то возвращаем обработчик, который возвращает ошибку.
        if err != nil </span><span class="cov8" title="1">{
                return func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                        response.Error(w, err, http.StatusInternalServerError)
                }</span>
        }

        // Запускаем обработчик запроса с созданным хранилищем.
        <span class="cov0" title="0">return Handle(db)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package update реализует обработчик для обновления метрик в формате JSON.
// Предоставляет эндпоинт для обновления значений отдельных метрик.
package update

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
        "github.com/maynagashev/go-metrics/pkg/response"
        "github.com/maynagashev/go-metrics/pkg/sign"
)

type ResponseWithMessage struct {
        Message string `json:"message"`
}

type Metric struct {
        Name  string             `json:"id"`              // Имя метрики
        MType metrics.MetricType `json:"type"`            // Параметр, принимающий значение gauge или counter
        Delta *int64             `json:"delta,omitempty"` // Значение метрики в случае передачи counter
        Value *float64           `json:"value,omitempty"` // Значение метрики в случае передачи gauge
}

// New возвращает http.HandlerFunc, который обновляет значение метрики в хранилище.
func New(cfg *app.Config, strg storage.Repository, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                requestedMetric, err := parseMetricFromRequest(r, log, cfg)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error("error while parsing metric", zap.Error(err))
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">log.Debug("parsed metric", zap.Any("metric", requestedMetric))

                // Конвертируем локальную структуру в структуру из контракта
                metric := metrics.Metric(requestedMetric)
                err = strg.UpdateMetric(r.Context(), metric)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">var resMessage string

                // Получаем значение метрики из хранилища
                m, ok := strg.GetMetric(r.Context(), metric.MType, metric.Name)
                if ok </span><span class="cov8" title="1">{
                        resMessage = fmt.Sprintf("metric %s updated, result: %s", metric.String(), m.String())
                }</span> else<span class="cov0" title="0"> {
                        resMessage = fmt.Sprintf("metric %s not found", metric.String())
                }</span>

                // Логируем ответ для отладки
                <span class="cov8" title="1">log.Info(resMessage)

                // Отправляем успешный ответ
                response.OK(w, resMessage)</span>
        }
}

// Читаем метрику из json запроса.
func parseMetricFromRequest(r *http.Request, log *zap.Logger, cfg *app.Config) (Metric, error) <span class="cov8" title="1">{
        m := Metric{}
        buf := new(bytes.Buffer)
        _, err := buf.ReadFrom(r.Body)

        if err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>

        <span class="cov8" title="1">log.Debug("request body", zap.String("body", buf.String()))

        body := buf.Bytes()

        if cfg.IsRequestSigningEnabled() </span><span class="cov8" title="1">{
                // Проверяем подпись запроса
                expectedHash := r.Header.Get(sign.HeaderKey)
                requestHash, vErr := sign.VerifyHMACSHA256(body, cfg.PrivateKey, expectedHash)
                if vErr != nil </span><span class="cov8" title="1">{
                        log.Error("error while verifying request signature", zap.Error(vErr),
                                zap.String("expected_hash", expectedHash), zap.String("request_hash", requestHash))
                        return m, vErr
                }</span>
        }

        <span class="cov8" title="1">err = json.Unmarshal(body, &amp;m)
        if err != nil </span><span class="cov8" title="1">{
                return m, err
        }</span>

        <span class="cov8" title="1">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package updates реализует обработчик для пакетного обновления метрик в формате JSON.
// Предоставляет эндпоинт для одновременного обновления нескольких метрик.
package updates

import (
        "bytes"
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
        "github.com/maynagashev/go-metrics/pkg/response"
        sign "github.com/maynagashev/go-metrics/pkg/sign"
)

// NewBulkUpdate возвращает http.HandlerFunc, который обновляет множество метрик в хранилище.
// Метрики передаются в теле запроса в формате JSON.
func NewBulkUpdate(cfg *app.Config, st storage.Repository, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var err error
                w.Header().Set("Content-Type", "application/json")

                // Проверяем запрос на валидность и подпись если требуется.
                body, err := validateRequest(r, log, cfg)
                if err != nil </span><span class="cov8" title="1">{
                        log.Debug("validate request failed", zap.Error(err))
                        response.Error(w, err, http.StatusBadRequest)
                        return
                }</span>

                // Парсим тело запроса в слайс метрик.
                <span class="cov8" title="1">var metricsToUpdate []metrics.Metric
                err = json.Unmarshal([]byte(body), &amp;metricsToUpdate)
                if err != nil </span><span class="cov8" title="1">{
                        log.Debug("json decode failed", zap.Error(err))
                        response.Error(w, err, http.StatusBadRequest)
                        return
                }</span>

                // Обновляем метрики в хранилище.
                <span class="cov8" title="1">err = st.UpdateMetrics(r.Context(), metricsToUpdate)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>

                // Отправляем успешный ответ.
                <span class="cov8" title="1">w.WriteHeader(http.StatusOK)

                // Логируем ответ для отладки
                log.Info("Metrics updated successfully")

                // Выводим в тело ответа сообщение о результате
                response.OK(w, "Metrics updated successfully")</span>
        }
}

// validateRequest проверяет запрос на валидность.
func validateRequest(r *http.Request, log *zap.Logger, cfg *app.Config) (string, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        _, err := buf.ReadFrom(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">body := buf.Bytes()

        // Проверяем подпись запроса
        if cfg.IsRequestSigningEnabled() </span><span class="cov8" title="1">{
                hashFromRequest := r.Header.Get(sign.HeaderKey)
                hash, vErr := sign.VerifyHMACSHA256(body, cfg.PrivateKey, hashFromRequest)

                log.Debug(
                        "validateRequest =&gt; sign.VerifyHMACSHA256",
                        zap.String("hash_from_request", hashFromRequest),
                        zap.Error(
                                vErr,
                        ),
                        zap.String("calc_hash", hash),
                        zap.Any("headers", r.Header),
                        zap.String("body", buf.String()),
                )

                if vErr != nil </span><span class="cov8" title="1">{
                        return "", vErr
                }</span>
        }

        <span class="cov8" title="1">return buf.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package value provides a handler for the /value endpoint.
package value

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
        "github.com/maynagashev/go-metrics/pkg/sign"
)

// New хэндлер для получения значения метрики с сервера в ответ на запрос `POST /value`.
func New(cfg *app.Config, storage storage.Repository) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                var err error

                requestMetric, err := parseMetricFromRequest(r)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>

                // Получаем значение метрики из хранилища
                <span class="cov8" title="1">metric, ok := storage.GetMetric(r.Context(), requestMetric.MType, requestMetric.Name)
                if !ok </span><span class="cov8" title="1">{
                        http.Error(w, fmt.Sprintf("%s not found", metric.String()), http.StatusNotFound)
                        return
                }</span>

                // Отправляем json ответ с метрикой
                <span class="cov8" title="1">encodedBody, err := json.Marshal(metric)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                // Если задан приватный ключ, то подписываем ответ
                <span class="cov8" title="1">if cfg.IsRequestSigningEnabled() </span><span class="cov8" title="1">{
                        signature := sign.ComputeHMACSHA256(encodedBody, cfg.PrivateKey)
                        w.Header().Set(sign.HeaderKey, signature)
                }</span>

                <span class="cov8" title="1">_, err = w.Write(encodedBody)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        }
}

// Читаем метрику из json запроса.
func parseMetricFromRequest(r *http.Request) (metrics.Metric, error) <span class="cov8" title="1">{
        m := metrics.Metric{}
        buf := new(bytes.Buffer)
        _, err := buf.ReadFrom(r.Body)

        if err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(buf.Bytes(), &amp;m)
        if err != nil </span><span class="cov8" title="1">{
                return m, err
        }</span>

        <span class="cov8" title="1">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package index реализует обработчик для получения списка метрик в текстовом формате.
// Предоставляет эндпоинт для получения человекочитаемого представления метрик.
package index

import (
        "fmt"
        "net/http"
        "strconv"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/storage"
)

// New возвращает http.HandlerFunc, который отдает список метрик на сервере.
func New(st storage.Repository) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "text/html")

                // Возвращаем метрики в виде списка строк (первоначальный вариант)
                ms := st.GetMetrics(r.Context())
                items := make([]string, 0, st.Count(r.Context()))
                for _, metric := range ms </span><span class="cov8" title="1">{
                        switch metric.MType </span>{
                        case metrics.TypeGauge:<span class="cov8" title="1">
                                valF := strconv.FormatFloat(*metric.Value, 'f', -1, 64)
                                items = append(items, fmt.Sprintf("gauge/%s: %s", metric.Name, valF))</span>
                        case metrics.TypeCounter:<span class="cov8" title="1">
                                items = append(items, fmt.Sprintf("counter/%s: %d", metric.Name, *metric.Delta))</span>
                        default:<span class="cov8" title="1">
                                items = append(items, fmt.Sprintf("unknown/%s", metric.Name))</span>
                        }
                }

                <span class="cov8" title="1">for _, metric := range items </span><span class="cov8" title="1">{
                        _, err := w.Write([]byte(metric + "\n"))
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package update реализует обработчик для обновления метрик в текстовом формате.
// Предоставляет эндпоинт для обновления значений метрик через простой текстовый интерфейс.
package update

import (
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/storage"
)

// New возвращает http.HandlerFunc, который обновляет значение метрики в хранилище.
func New(st storage.Repository, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "text/plain")

                // Получаем части пути из URL /update/&lt;ТИП_МЕТРИКИ&gt;/&lt;ИМЯ_МЕТРИКИ&gt;/&lt;ЗНАЧЕНИЕ_МЕТРИКИ&gt;
                parts := strings.Split(r.URL.Path, "/")
                expectedPartsLen := 5

                // При попытке передать запрос без имени метрики возвращать http.StatusNotFound.
                if len(parts) != expectedPartsLen </span><span class="cov8" title="1">{
                        http.Error(w, "Page not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov8" title="1">metricType := metrics.MetricType(parts[2])
                metricName := parts[3]
                metricValue := parts[4]

                var m *metrics.Metric
                switch metricType </span>{
                case metrics.TypeCounter:<span class="cov8" title="1">
                        intValue, err := strconv.ParseInt(metricValue, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(
                                        w,
                                        "Invalid metrics value, must be convertable to int64",
                                        http.StatusBadRequest,
                                )
                                return
                        }</span>
                        <span class="cov8" title="1">m = metrics.NewCounter(metricName, intValue)</span>
                case metrics.TypeGauge:<span class="cov8" title="1">
                        floatValue, err := strconv.ParseFloat(metricValue, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(
                                        w,
                                        "Invalid metrics value, must be convertable to float64",
                                        http.StatusBadRequest,
                                )
                                return
                        }</span>
                        <span class="cov8" title="1">m = metrics.NewGauge(metricName, floatValue)</span>
                default:<span class="cov8" title="1">
                        http.Error(w, "Invalid metrics type, must be: counter or gauge", http.StatusBadRequest)
                        return</span>
                }

                // Обновляем метрику в хранилище
                <span class="cov8" title="1">err := st.UpdateMetric(r.Context(), *m)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>

                <span class="cov8" title="1">var resMessage string
                // Получаем значение метрики из хранилища
                v, ok := st.GetMetric(r.Context(), metricType, metricName)
                if ok </span><span class="cov8" title="1">{
                        resMessage = fmt.Sprintf("metric %s/%s updated with value %s, result: %s",
                                metricType, metricName, metricValue, v.String())
                }</span> else<span class="cov0" title="0"> {
                        resMessage = fmt.Sprintf("metric %s/%s not found", metricType, metricName)
                }</span>

                // Отправляем успешный ответ
                <span class="cov8" title="1">w.WriteHeader(http.StatusOK)

                // Логируем ответ для отладки
                log.Info(resMessage)

                // Выводим в тело ответа сообщение о результате
                _, err = fmt.Fprint(w, resMessage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("error writing response: %s", err))
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package value provides a handler for the /value endpoint.
package value

import (
        "fmt"
        "net/http"

        "github.com/go-chi/chi/v5"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/storage"
)

// New хэндлер для получения занчения метрики с сервера /value/{type}/{name}.
func New(storage storage.Repository) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "text/plain")

                metricType := metrics.MetricType(chi.URLParam(r, "type"))
                metricName := chi.URLParam(r, "name")

                metric, ok := storage.GetMetric(r.Context(), metricType, metricName)
                if !ok </span><span class="cov8" title="1">{
                        http.Error(
                                w,
                                fmt.Sprintf("%s %s not found", metricType, metricName),
                                http.StatusNotFound,
                        )
                        return
                }</span>

                <span class="cov8" title="1">_, err := w.Write([]byte(metric.ValueString()))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package decompress содержит middleware которое отвечает за обработку сжатых запросов,
// когда от клиента пришел заголовок Content-Encoding: gzip.
package decompress

import (
        "compress/gzip"
        "net/http"

        "go.uber.org/zap"
)

func New(log *zap.Logger) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        // Возвращаем функцию, которая принимает следующий обработчик
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                log.Info("decompress middleware enabled")

                // Функция-обработчик запроса
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Проверяем заголовок Content-Encoding: gzip
                        if r.Header.Get("Content-Encoding") == "gzip" </span><span class="cov8" title="1">{
                                log.Debug("content encoded with gzip, replacing body with gzip.Reader")

                                gz, err := gzip.NewReader(r.Body)
                                if err != nil </span><span class="cov8" title="1">{
                                        log.Error("error while decompressing request body", zap.Error(err))
                                        http.Error(
                                                w,
                                                "Ошибка при декомпрессии содержимого запроса gzip",
                                                http.StatusBadRequest,
                                        )
                                        return
                                }</span>

                                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                                        err = gz.Close()
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error("error while closing decompression stream", zap.Error(err))
                                                http.Error(
                                                        w,
                                                        "Ошибка при закрытии потока декомпрессии",
                                                        http.StatusInternalServerError,
                                                )
                                                return
                                        }</span>
                                }()

                                // Заменяем тело запроса на декомпрессированный поток
                                <span class="cov8" title="1">r.Body = gz</span>
                        }
                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                }
                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package decompresspool содержит middleware которое отвечает за обработку сжатых запросов,
// когда от клиента пришел заголовок Content-Encoding: gzip.
package decompresspool

import (
        "compress/gzip"
        "io"
        "net/http"
        "sync"

        "go.uber.org/zap"
)

// Middleware содержит пулы для переиспользования объектов.
type Middleware struct {
        log        *zap.Logger
        readerPool sync.Pool
        closerPool sync.Pool
}

// New создает новый middleware для декомпрессии с пулами объектов.
func New(log *zap.Logger) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        m := &amp;Middleware{
                log: log,
                readerPool: sync.Pool{
                        New: func() interface{} </span><span class="cov8" title="1">{
                                return new(gzip.Reader)
                        }</span>,
                },
                closerPool: sync.Pool{
                        New: func() interface{} <span class="cov8" title="1">{
                                return new(gzipReadCloser)
                        }</span>,
                },
        }

        <span class="cov8" title="1">return m.Handler</span>
}

// Handler возвращает функцию-обработчик запроса.
func (m *Middleware) Handler(next http.Handler) http.Handler <span class="cov8" title="1">{
        m.log.Info("decompress middleware enabled")

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Header.Get("Content-Encoding") != "gzip" </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">m.log.Debug("content encoded with gzip, replacing body with gzip.Reader")

                // Получаем Reader из пула
                reader, ok := m.readerPool.Get().(*gzip.Reader)
                if !ok </span><span class="cov0" title="0">{
                        m.log.Error("error getting reader from pool")
                        http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                        return
                }</span>

                // Инициализируем Reader новым источником данных
                <span class="cov8" title="1">if err := reader.Reset(r.Body); err != nil </span><span class="cov8" title="1">{
                        m.log.Error("error initializing gzip reader", zap.Error(err))
                        m.readerPool.Put(reader)
                        http.Error(w, "Ошибка при декомпрессии содержимого запроса gzip", http.StatusBadRequest)
                        return
                }</span>

                // Получаем closer из пула
                <span class="cov8" title="1">closer, ok := m.closerPool.Get().(*gzipReadCloser)
                if !ok </span><span class="cov0" title="0">{
                        m.log.Error("error getting closer from pool")
                        m.readerPool.Put(reader)
                        http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                        return
                }</span>

                // Инициализируем closer
                <span class="cov8" title="1">closer.Reader = reader
                closer.middleware = m
                closer.log = m.log
                closer.originalBody = r.Body

                // Заменяем тело запроса
                r.Body = closer

                next.ServeHTTP(w, r)</span>
        })
}

// gzipReadCloser оборачивает gzip.Reader для автоматического возврата в пул при закрытии.
type gzipReadCloser struct {
        *gzip.Reader
        middleware   *Middleware
        log          *zap.Logger
        originalBody io.ReadCloser
}

func (gz *gzipReadCloser) Close() error <span class="cov0" title="0">{
        // Закрываем gzip reader
        if err := gz.Reader.Close(); err != nil </span><span class="cov0" title="0">{
                gz.log.Error("error closing gzip reader", zap.Error(err))
                return err
        }</span>

        // Закрываем оригинальное тело
        <span class="cov0" title="0">if err := gz.originalBody.Close(); err != nil </span><span class="cov0" title="0">{
                gz.log.Error("error closing original body", zap.Error(err))
                return err
        }</span>

        // Возвращаем Reader в его пул
        <span class="cov0" title="0">gz.middleware.readerPool.Put(gz.Reader)

        // Очищаем поля перед возвратом в пул
        gz.Reader = nil
        gz.originalBody = nil
        gz.log = nil
        gz.middleware = nil

        // Возвращаем closer в его пул
        gz.middleware.closerPool.Put(gz)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package ipfilter содержит middleware для фильтрации запросов по IP-адресу.
// Проверяет, что IP-адрес клиента входит в доверенную подсеть.
package ipfilter

import (
        "net"
        "net/http"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/server/app"
)

// Middleware представляет middleware для фильтрации запросов по IP-адресу.
type Middleware struct {
        log    *zap.Logger
        config *app.Config
        subnet *net.IPNet
}

// New создает новый middleware для фильтрации запросов по IP-адресу.
func New(config *app.Config, log *zap.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        m := &amp;Middleware{
                log:    log,
                config: config,
        }

        // Если указана доверенная подсеть, парсим её
        if config.IsTrustedSubnetEnabled() </span><span class="cov8" title="1">{
                _, ipNet, err := net.ParseCIDR(config.TrustedSubnet)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error("failed to parse trusted subnet CIDR",
                                zap.String("cidr", config.TrustedSubnet),
                                zap.Error(err))
                }</span> else<span class="cov8" title="1"> {
                        m.subnet = ipNet
                        log.Info("trusted subnet enabled",
                                zap.String("cidr", config.TrustedSubnet))
                }</span>
        }

        <span class="cov8" title="1">return m.Handler</span>
}

// Handler обрабатывает запрос, проверяя IP-адрес клиента.
func (m *Middleware) Handler(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Если доверенная подсеть не указана или не удалось её распарсить, пропускаем запрос
                if m.subnet == nil </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Получаем IP-адрес из заголовка X-Real-IP
                <span class="cov8" title="1">ipStr := r.Header.Get("X-Real-IP")
                if ipStr == "" </span><span class="cov8" title="1">{
                        m.log.Warn("request without X-Real-IP header",
                                zap.String("remote_addr", r.RemoteAddr))
                        // Если доверенная подсеть указана, запрещаем запрос без X-Real-IP
                        http.Error(w, "X-Real-IP header is required", http.StatusForbidden)
                        return
                }</span>

                // Парсим IP-адрес
                <span class="cov8" title="1">ip := net.ParseIP(ipStr)
                if ip == nil </span><span class="cov8" title="1">{
                        m.log.Warn("invalid IP address in X-Real-IP header",
                                zap.String("ip", ipStr))
                        http.Error(w, "Invalid IP address", http.StatusBadRequest)
                        return
                }</span>

                // Проверяем, входит ли IP-адрес в доверенную подсеть
                <span class="cov8" title="1">if !m.subnet.Contains(ip) </span><span class="cov8" title="1">{
                        m.log.Warn("IP address not in trusted subnet",
                                zap.String("ip", ipStr),
                                zap.String("subnet", m.config.TrustedSubnet))
                        http.Error(w, "Forbidden", http.StatusForbidden)
                        return
                }</span>

                // IP-адрес входит в доверенную подсеть, пропускаем запрос
                <span class="cov8" title="1">m.log.Debug("IP address in trusted subnet",
                        zap.String("ip", ipStr),
                        zap.String("subnet", m.config.TrustedSubnet))
                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package logger реализует middleware для логирования HTTP-запросов.
// Обеспечивает логирование всех входящих запросов и их результатов.
package logger

import (
        "bytes"
        "io"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"
)

func New(log *zap.Logger) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                log.Info("logger middleware enabled")

                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        entry := log.With(
                                zap.String("method", r.Method),
                                zap.String("path", r.URL.Path),
                                zap.String("remote_addr", r.RemoteAddr),
                                zap.String("user_agent", r.UserAgent()),
                                zap.String("request_id", middleware.GetReqID(r.Context())),
                                // Добавляем логирование заголовков запроса
                                zap.Any("headers", r.Header),
                                // Добавляем логирование тела запроса
                                zap.String("request_body", string(readRequestBody(r, log))),
                        )
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        // Сохраняем тело ответа для записи в лог
                        body := bytes.NewBuffer(nil)
                        ww.Tee(body)

                        t1 := time.Now()
                        defer func() </span><span class="cov8" title="1">{
                                entry.Info("request completed",
                                        zap.Int("status", ww.Status()),
                                        zap.Int("response_bytes", ww.BytesWritten()),
                                        zap.Any("response_headers", ww.Header()),   // Логирование заголовков ответа
                                        zap.String("response_body", body.String()), // Логирование тела ответа
                                        zap.String("duration", time.Since(t1).String()),
                                )
                        }</span>()

                        <span class="cov8" title="1">next.ServeHTTP(ww, r)</span>
                }

                // приводим к нужному типу
                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}

func readRequestBody(r *http.Request, log *zap.Logger) []byte <span class="cov8" title="1">{
        reqBody, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Ошибка при чтении тела запроса", zap.Error(err))
                return nil
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := r.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Error("Ошибка при закрытии тела запроса", zap.Error(closeErr))
                }</span>
        }()

        // Восстановление r.Body для дальнейшего использования
        <span class="cov8" title="1">r.Body = io.NopCloser(bytes.NewBuffer(reqBody))
        return reqBody</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package router реализует маршрутизацию HTTP-запросов.
// Определяет все доступные эндпоинты и связывает их с соответствующими обработчиками.
package router

import (
        "net/http/pprof"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/handlers/json/ping"
        jsonUpdate "github.com/maynagashev/go-metrics/internal/server/handlers/json/update"
        jsonUpdates "github.com/maynagashev/go-metrics/internal/server/handlers/json/updates"
        jasonValue "github.com/maynagashev/go-metrics/internal/server/handlers/json/value"
        plainIndex "github.com/maynagashev/go-metrics/internal/server/handlers/plain/index"
        plainUpdate "github.com/maynagashev/go-metrics/internal/server/handlers/plain/update"
        plainValue "github.com/maynagashev/go-metrics/internal/server/handlers/plain/value"
        "github.com/maynagashev/go-metrics/internal/server/middleware/decompresspool"
        "github.com/maynagashev/go-metrics/internal/server/middleware/ipfilter"
        "github.com/maynagashev/go-metrics/internal/server/middleware/logger"
        "github.com/maynagashev/go-metrics/internal/server/storage"
        cryptoMiddleware "github.com/maynagashev/go-metrics/pkg/middleware/crypto"
)

// New инстанцирует новый роутер.
func New(config *app.Config, storage storage.Repository, log *zap.Logger) chi.Router <span class="cov8" title="1">{
        compressLevel := 5

        r := chi.NewRouter()

        // Добавляем middleware для генерации ID запроса
        r.Use(middleware.RequestID)
        // Восстанавливаем панику, если она произошла внутри обработчика
        r.Use(middleware.Recoverer)
        // Удаляем слеши в конце URL
        r.Use(middleware.StripSlashes)
        // Добавляем middleware для сжатия ответов
        r.Use(middleware.Compress(compressLevel, "application/json", "text/html"))
        // Обработка сжатых запросов, когда от клиента сразу пришел заголовок Content-Encoding: gzip
        r.Use(decompresspool.New(log))
        // Используем единый логгер для запросов, вместо встроенного логгера chi
        r.Use(logger.New(log))
        // Добавляем middleware для проверки IP-адреса
        r.Use(ipfilter.New(config, log))
        // Добавляем middleware для обработки шифрования
        r.Use(cryptoMiddleware.New(config, log))

        // Обработчики запросов
        r.Get("/", plainIndex.New(storage))
        r.Post("/update", jsonUpdate.New(config, storage, log))
        r.Post("/updates", jsonUpdates.NewBulkUpdate(config, storage, log))
        r.Post("/value", jasonValue.New(config, storage))
        r.Get("/ping", ping.New(config, log))

        // Первые версии обработчиков для работы тестов начальных итераций
        r.Post("/update/*", plainUpdate.New(storage, log))
        r.Get("/value/{type}/{name}", plainValue.New(storage))

        // Добавляем pprof хендлеры только если включено профилирование
        if config.EnablePprof </span><span class="cov8" title="1">{
                log.Info("Registering pprof handlers at /debug/pprof/")
                r.Route("/debug/pprof", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.HandleFunc("/", pprof.Index)
                        r.HandleFunc("/cmdline", pprof.Cmdline)
                        r.HandleFunc("/profile", pprof.Profile)
                        r.HandleFunc("/symbol", pprof.Symbol)
                        r.HandleFunc("/trace", pprof.Trace)

                        /* Постоянно обновляемые метрики, снимают отчеты в реальном времени */
                        r.HandleFunc("/goroutine", pprof.Handler("goroutine").ServeHTTP)
                        r.HandleFunc("/heap", pprof.Handler("heap").ServeHTTP)
                        r.HandleFunc("/threadcreate", pprof.Handler("threadcreate").ServeHTTP)
                        r.HandleFunc("/block", pprof.Handler("block").ServeHTTP)
                        r.HandleFunc("/allocs", pprof.Handler("allocs").ServeHTTP)
                        r.HandleFunc("/mutex", pprof.Handler("mutex").ServeHTTP)
                }</span>)
        }

        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package memory provides an in-memory storage for metrics.
package memory

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "time"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
)

const maxRetries = 3

type MemStorage struct {
        gauges   storage.Gauges
        counters storage.Counters
        cfg      *app.Config
        log      *zap.Logger
}

// New создает новый экземпляр хранилища метрик в памяти, на вход
// можно передать набор gauges или counters для инициализации в тестах.
func New(cfg *app.Config, log *zap.Logger, options ...interface{}) *MemStorage <span class="cov8" title="1">{
        memStorage := &amp;MemStorage{
                gauges:   make(storage.Gauges),
                counters: make(storage.Counters),
                cfg:      cfg,
                log:      log,
        }
        log.Debug("memory storage created", zap.Any("storage", memStorage))

        // Если включено восстановление метрик из файла, то пытаемся прочитать метрики из файла.
        if cfg.IsRestoreEnabled() </span><span class="cov8" title="1">{
                err := memStorage.restoreMetricsFromFile()
                if err != nil </span><span class="cov8" title="1">{
                        log.Error("failed to read metrics from file", zap.Error(err))
                }</span>
        }

        // Если переданы метрики для инициализации (для тестов хранилища) то обновляем их в хранилище.
        <span class="cov8" title="1">for _, option := range options </span><span class="cov0" title="0">{
                switch opt := option.(type) </span>{
                case storage.Gauges:<span class="cov0" title="0">
                        memStorage.gauges = opt</span>
                case storage.Counters:<span class="cov0" title="0">
                        memStorage.counters = opt</span>
                }
        }

        // Запускаем сохранение метрик в файл с указанным интервалом.
        <span class="cov8" title="1">if cfg.IsStoreEnabled() &amp;&amp; !cfg.IsSyncStore() </span><span class="cov0" title="0">{
                interval := time.Duration(cfg.GetStoreInterval()) * time.Second
                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                time.Sleep(interval)
                                log.Info(
                                        fmt.Sprintf(
                                                "store %d metrics to file %s",
                                                memStorage.Count(context.Background()),
                                                cfg.GetStorePath(),
                                        ),
                                )
                                err := memStorage.storeMetricsToFile()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("failed to store metrics to file", zap.Error(err))
                                }</span>
                        }
                }()
        }

        <span class="cov8" title="1">return memStorage</span>
}

func (ms *MemStorage) Close() error <span class="cov8" title="1">{
        if ms.cfg.IsStoreEnabled() &amp;&amp; !ms.cfg.IsSyncStore() </span><span class="cov0" title="0">{
                return ms.storeMetricsToFile()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateGauge перезаписывает значение gauge.
func (ms *MemStorage) UpdateGauge(metricName string, metricValue storage.Gauge) <span class="cov8" title="1">{
        ms.gauges[metricName] = metricValue
}</span>

// IncrementCounter увеличивает значение счетчика на заданное значение.
func (ms *MemStorage) IncrementCounter(metricName string, metricValue storage.Counter) <span class="cov8" title="1">{
        ms.counters[metricName] += metricValue
}</span>

// UpdateMetric универсальный метод обновления метрики в хранилище: gauge, counter.
func (ms *MemStorage) UpdateMetric(_ context.Context, metric metrics.Metric) error <span class="cov8" title="1">{
        switch metric.MType </span>{
        case metrics.TypeGauge:<span class="cov8" title="1">
                if metric.Value == nil </span><span class="cov0" title="0">{
                        return errors.New("gauge value is nil")
                }</span>
                <span class="cov8" title="1">ms.UpdateGauge(metric.Name, storage.Gauge(*metric.Value))</span>
        case metrics.TypeCounter:<span class="cov8" title="1">
                if metric.Delta == nil </span><span class="cov0" title="0">{
                        return errors.New("counter delta is nil")
                }</span>
                <span class="cov8" title="1">ms.IncrementCounter(metric.Name, storage.Counter(*metric.Delta))</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported metric type: %s", metric.MType)</span>
        }

        // Сохраняем метрики в файл сразу после изменения, если включено синхронное сохранение.
        <span class="cov8" title="1">if ms.cfg.IsStoreEnabled() &amp;&amp; ms.cfg.IsSyncStore() </span><span class="cov8" title="1">{
                err := ms.storeMetricsToFile()
                if err != nil </span><span class="cov0" title="0">{
                        // Информация об ошибке синхронной записи для клиента может быть избыточной, поэтому просто логируем ошибку.
                        ms.log.Error(
                                fmt.Sprintf("error while trying to syncroniously store metrics to file: %s", err),
                        )
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ms *MemStorage) UpdateMetrics(ctx context.Context, items []metrics.Metric) error <span class="cov8" title="1">{
        for _, item := range items </span><span class="cov8" title="1">{
                err := ms.UpdateMetric(ctx, item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ms *MemStorage) GetGauges() storage.Gauges <span class="cov8" title="1">{
        return ms.gauges
}</span>

func (ms *MemStorage) GetCounters() storage.Counters <span class="cov8" title="1">{
        return ms.counters
}</span>

func (ms *MemStorage) GetGauge(_ context.Context, name string) (storage.Gauge, bool) <span class="cov8" title="1">{
        value, ok := ms.gauges[name]
        return value, ok
}</span>

func (ms *MemStorage) GetCounter(_ context.Context, name string) (storage.Counter, bool) <span class="cov8" title="1">{
        value, ok := ms.counters[name]
        return value, ok
}</span>

func (ms *MemStorage) Count(_ context.Context) int <span class="cov8" title="1">{
        return len(ms.gauges) + len(ms.counters)
}</span>

func (ms *MemStorage) GetMetric(
        ctx context.Context,
        mType metrics.MetricType,
        id string,
) (metrics.Metric, bool) <span class="cov8" title="1">{
        switch mType </span>{
        case metrics.TypeCounter:<span class="cov8" title="1">
                v, ok := ms.GetCounter(ctx, id)
                return metrics.Metric{
                        Name:  id,
                        MType: mType,
                        Delta: (*int64)(&amp;v),
                }, ok</span>
        case metrics.TypeGauge:<span class="cov8" title="1">
                v, ok := ms.GetGauge(ctx, id)
                return metrics.Metric{
                        Name:  id,
                        MType: mType,
                        Value: (*float64)(&amp;v),
                }, ok</span>
        }
        <span class="cov0" title="0">return metrics.Metric{}, false</span>
}

// GetMetrics возвращает отсортированный список метрик в формате слайса структур.
func (ms *MemStorage) GetMetrics(ctx context.Context) []metrics.Metric <span class="cov8" title="1">{
        items := make([]metrics.Metric, 0, ms.Count(ctx))
        for id, value := range ms.GetGauges() </span><span class="cov8" title="1">{
                items = append(
                        items,
                        metrics.Metric{Name: id, MType: metrics.TypeGauge, Value: (*float64)(&amp;value)},
                )
        }</span>
        <span class="cov8" title="1">for id, value := range ms.GetCounters() </span><span class="cov8" title="1">{
                items = append(
                        items,
                        metrics.Metric{Name: id, MType: metrics.TypeCounter, Delta: (*int64)(&amp;value)},
                )
        }</span>
        // slices.Sort(items)
        <span class="cov8" title="1">return items</span>
}

// StoreMetricsToFile сохраняет метрики в файл.
func (ms *MemStorage) storeMetricsToFile() error <span class="cov8" title="1">{
        path := ms.cfg.GetStorePath()
        ms.log.Debug("store metrics to file",
                zap.String("path", path),
                zap.Any("gauges", ms.GetGauges()),
                zap.Any("counters", ms.GetCounters()))

        var f *os.File
        var err error

        for i := 0; i &lt;= maxRetries; i++ </span><span class="cov8" title="1">{
                // попытка открытия файла для записи
                f, err = os.Create(path)
                if err == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">ms.log.Error(fmt.Sprintf("Attempt %d: Error opening file: %v", i+1, err))
                time.Sleep(time.Duration((i+1)*2-1) * time.Second)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open file after %d attempts: %w", maxRetries, err)
        }</span>

        // отложенное закрытие файла
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ms.log.Error(fmt.Sprintf("error closing file: %s", err))
                }</span>
        }()

        // сериализация метрик metrics.Metric в json и запись сразу в файл
        <span class="cov8" title="1">encoder := json.NewEncoder(f)
        encoder.SetIndent("", "    ")
        err = encoder.Encode(ms.GetMetrics(context.Background()))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RestoreMetricsFromFile загружает метрики из файла.
func (ms *MemStorage) restoreMetricsFromFile() error <span class="cov8" title="1">{
        path := ms.cfg.GetStorePath()
        ms.log.Debug("load metrics from file", zap.String("path", path))

        // открытие файла для чтения и парсинг json метрик metrics.Metric
        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ms.log.Error(fmt.Sprintf("error closing file: %s", err), zap.Any("file", f))
                }</span>
        }()

        // парсинг json метрик metrics.Metric
        <span class="cov8" title="1">var parsed []metrics.Metric
        decoder := json.NewDecoder(f)
        err = decoder.Decode(&amp;parsed)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // обновление метрик в хранилище в памяти
        <span class="cov8" title="1">for m := range parsed </span><span class="cov8" title="1">{
                err = ms.UpdateMetric(context.Background(), parsed[m])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Выводим информацию о восстановленных метриках в лог.
        <span class="cov8" title="1">ms.log.Info(
                "Metrics restored from file",
                zap.String("file", ms.cfg.GetStorePath()),
                zap.Int("metrics", len(ms.GetMetrics(context.Background()))),
        )
        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package migration предоставляет функционал для управления миграциями базы данных.
// Обеспечивает корректное обновление схемы базы данных при изменениях.
package migration

import (
        "errors"
        "log/slog"

        "github.com/golang-migrate/migrate/v4"
        // Подключение драйвера для работы с PostgreSQL.
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        // Подключение драйвера файловой системы, для чтения миграций из файлов.
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

// Up выполняет миграции базы данных.
func Up(migrationsPath string, dsn string) error <span class="cov0" title="0">{
        var err error
        slog.Info("Запуск миграций...", "path", migrationsPath)
        m, err := migrate.New("file://"+migrationsPath, dsn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">if err = m.Up(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        slog.Info("Нет новых миграций для применения.")
                        return nil
                }</span>
                <span class="cov0" title="0">panic(err)</span>
        }

        <span class="cov0" title="0">slog.Info("Миграции применены.")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package pgstorage реализует хранилище метрик на основе PostgreSQL.
// Предоставляет методы для сохранения и получения метрик из базы данных.
package pgstorage

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/internal/server/storage"
        "github.com/maynagashev/go-metrics/internal/server/storage/pgstorage/migration"
)

const maxRetries = 3

// PgxPoolInterface определяет интерфейс для pgxpool.Pool, чтобы можно было использовать мок в тестах.
type PgxPoolInterface interface {
        Close()
        Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
        Begin(ctx context.Context) (pgx.Tx, error)
}

// Убедимся, что pgxpool.Pool реализует наш интерфейс.
var _ PgxPoolInterface = (*pgxpool.Pool)(nil)

type PgStorage struct {
        conn PgxPoolInterface
        cfg  *app.Config
        log  *zap.Logger
}

// New создает новое подключение к базе данных, накатывает миграции и возвращает экземпляр хранилища.
func New(ctx context.Context, config *app.Config, log *zap.Logger) (*PgStorage, error) <span class="cov0" title="0">{
        conn, err := pgxpool.New(ctx, config.Database.DSN)
        log.Debug(fmt.Sprintf("Connecting to database: %s\n", config.Database.DSN))

        if err != nil </span><span class="cov0" title="0">{
                log.Error(fmt.Sprintf("Unable to connect to database: %v\n", err))
                return nil, err
        }</span>

        <span class="cov0" title="0">p := &amp;PgStorage{
                conn: conn,
                cfg:  config,
                log:  log,
        }

        // Автоматически накатываем миграции при создании экземпляра хранилища.
        if migrateErr := migration.Up(config.Database.MigrationsPath, config.Database.DSN); migrateErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply migrations: %w", migrateErr)
        }</span>
        <span class="cov0" title="0">return p, nil</span>
}

// Close закрывает соединение с базой данных.
// Метод всегда возвращает nil, так как pgxpool.Close() не возвращает ошибку,
// но интерфейс Repository требует возврата error.
func (p *PgStorage) Close() error <span class="cov8" title="1">{
        if p.conn != nil </span><span class="cov0" title="0">{
                p.conn.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *PgStorage) Count(ctx context.Context) int <span class="cov8" title="1">{
        var count int
        err := p.conn.QueryRow(ctx, `SELECT count(*) FROM metrics`).Scan(&amp;count)
        if err != nil </span><span class="cov8" title="1">{
                p.log.Error(err.Error())
        }</span>
        <span class="cov8" title="1">return count</span>
}

func (p *PgStorage) GetMetrics(ctx context.Context) []metrics.Metric <span class="cov0" title="0">{
        var items []metrics.Metric
        rows, err := p.conn.Query(ctx, `SELECT name, type, value, delta FROM metrics ORDER BY name`)
        if err != nil </span><span class="cov0" title="0">{
                p.log.Error(err.Error())
                return nil
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var metric metrics.Metric
                err = rows.Scan(&amp;metric.Name, &amp;metric.MType, &amp;metric.Value, &amp;metric.Delta)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Error(err.Error())
                        return nil
                }</span>
                <span class="cov0" title="0">items = append(items, metric)</span>
        }

        <span class="cov0" title="0">return items</span>
}

// GetMetric получение значения метрики указанного типа в виде универсальной структуры.
func (p *PgStorage) GetMetric(
        ctx context.Context,
        mType metrics.MetricType,
        name string,
) (metrics.Metric, bool) <span class="cov8" title="1">{
        q := `SELECT name, type, value, delta FROM public.metrics WHERE name = $1 AND type = $2`

        var metric metrics.Metric
        var err error
        for i := 0; i &lt;= maxRetries; i++ </span><span class="cov8" title="1">{
                row := p.conn.QueryRow(ctx, q, name, mType)
                err = row.Scan(&amp;metric.Name, &amp;metric.MType, &amp;metric.Value, &amp;metric.Delta)

                if err == nil </span><span class="cov8" title="1">{
                        return metric, true
                }</span>

                // Проверяем, является ли ошибка retriable
                <span class="cov8" title="1">var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                        if isRetriableError(pgErr) </span><span class="cov0" title="0">{
                                p.log.Error(fmt.Sprintf("Attempt %d: Retriable error getting metric: %v", i+1, err))
                                time.Sleep(time.Duration((i+1)*2-1) * time.Second)
                                continue</span>
                        }
                }

                // Если ошибка не retriable, выходим из цикла
                <span class="cov8" title="1">break</span>
        }

        // Логируем и возвращаем ошибку, если не удалось получить метрику
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                p.log.Error(fmt.Sprintf("Failed to get metric after %d tries: %v", maxRetries+1, err))
        }</span>
        <span class="cov8" title="1">return metrics.Metric{}, false</span>
}

// GetCounter возвращает счетчик по имени.
func (p *PgStorage) GetCounter(ctx context.Context, name string) (storage.Counter, bool) <span class="cov0" title="0">{
        m, ok := p.GetMetric(ctx, metrics.TypeCounter, name)
        if !ok </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">return storage.Counter(*m.Delta), true</span>
}

// GetGauge возвращает измерение по имени.
func (p *PgStorage) GetGauge(ctx context.Context, name string) (storage.Gauge, bool) <span class="cov0" title="0">{
        m, ok := p.GetMetric(ctx, metrics.TypeGauge, name)
        if !ok </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">return storage.Gauge(*m.Value), true</span>
}

func (p *PgStorage) UpdateMetric(ctx context.Context, metric metrics.Metric) error <span class="cov8" title="1">{
        var q string

        // Если метрика существует, то обновляем, иначе создаем новую.
        _, ok := p.GetMetric(ctx, metric.MType, metric.Name)
        if ok </span><span class="cov8" title="1">{
                q = `UPDATE metrics SET value = $3, delta = delta + $4 WHERE name = $1 AND type = $2`
        }</span> else<span class="cov8" title="1"> {
                q = `INSERT INTO metrics (name, type, value, delta) VALUES ($1, $2, $3, $4)`
        }</span>

        // Выполнение запроса
        <span class="cov8" title="1">_, err := p.conn.Exec(ctx, q, metric.Name, metric.MType, metric.Value, metric.Delta)
        if err != nil </span><span class="cov8" title="1">{
                p.log.Error(fmt.Sprintf("Failed to update metric: %v", err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateMetrics пакетно обновляет метрики в хранилище.
func (p *PgStorage) UpdateMetrics(ctx context.Context, items []metrics.Metric) error <span class="cov0" title="0">{
        var err error
        q := `INSERT INTO metrics (name, type, value, delta) 
          VALUES ($1, $2, $3, $4)
          ON CONFLICT (name, type) 
          DO UPDATE SET value = EXCLUDED.value, delta = metrics.delta + EXCLUDED.delta`

        // Начало транзакции
        tx, err := p.conn.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Откатываем транзакцию в случае ошибки
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if rErr := tx.Rollback(ctx); rErr != nil &amp;&amp; !errors.Is(rErr, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                p.log.Error(fmt.Sprintf("Failed to rollback transaction: %v", rErr))
                        }</span>
                }
        }()

        <span class="cov0" title="0">batch := &amp;pgx.Batch{}
        for _, item := range items </span><span class="cov0" title="0">{
                batch.Queue(q, item.Name, item.MType, item.Value, item.Delta)
        }</span>

        // Выполнение батч-запроса
        <span class="cov0" title="0">br := tx.SendBatch(ctx, batch)
        _, err = br.Exec()
        if errClose := br.Close(); errClose != nil </span><span class="cov0" title="0">{
                p.log.Error(fmt.Sprintf("Failed to close batch: %v", errClose))
                return errClose
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                p.log.Error(fmt.Sprintf("Failed to update metrics: %v", err))
                return err
        }</span>

        // Подтверждаем транзакцию
        <span class="cov0" title="0">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                p.log.Error(fmt.Sprintf("Failed to commit transaction: %v", err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Проверка, является ли ошибка retriable.
func isRetriableError(err *pgconn.PgError) bool <span class="cov8" title="1">{
        switch err.Code </span>{
        case pgerrcode.ConnectionException,
                pgerrcode.ConnectionDoesNotExist,
                pgerrcode.ConnectionFailure,
                pgerrcode.DiskFull:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package storage определяет интерфейсы и базовые типы для хранения метрик.
// Предоставляет общий интерфейс для различных реализаций хранилищ.
package storage

import (
        "context"
        "strconv"

        "github.com/maynagashev/go-metrics/internal/contracts/metrics"
)

type Gauge float64
type Counter int64
type Gauges map[string]Gauge
type Counters map[string]Counter

func (v Gauge) String() string <span class="cov8" title="1">{
        return strconv.FormatFloat(float64(v), 'f', -1, 64)
}</span>
func (v Counter) String() string <span class="cov8" title="1">{
        return strconv.FormatInt(int64(v), 10)
}</span>

// Repository предоставляет интерфейс для работы с хранилищем метрик.
type Repository interface {
        // Close закрывает хранилище метрик.
        Close() error

        // Count возвращает общее количество метрик в хранилище.
        Count(ctx context.Context) int

        // GetMetrics возвращает все метрики в виде структур.
        GetMetrics(ctx context.Context) []metrics.Metric

        // GetMetric получает значение метрики указанного типа.
        // Возвращает метрику и флаг, указывающий на её наличие в хранилище.
        GetMetric(ctx context.Context, mType metrics.MetricType, name string) (metrics.Metric, bool)

        // GetCounter возвращает значение счетчика по имени.
        // Возвращает значение и флаг, указывающий на наличие счетчика.
        GetCounter(ctx context.Context, name string) (Counter, bool)

        // GetGauge возвращает значение gauge-метрики по имени.
        // Возвращает значение и флаг, указывающий на наличие метрики.
        GetGauge(ctx context.Context, name string) (Gauge, bool)

        // UpdateMetric обновляет или создает метрику в хранилище.
        // Поддерживает типы gauge и counter.
        UpdateMetric(ctx context.Context, metric metrics.Metric) error

        // UpdateMetrics пакетно обновляет набор метрик в хранилище.
        UpdateMetrics(ctx context.Context, metrics []metrics.Metric) error
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package mocks содержит автоматически сгенерированные моки для тестирования.
// Предоставляет имитации интерфейсов хранилища для модульного тестирования.
// Code generated by mockery v2.43.1. DO NOT EDIT.
package mocks

import (
        metrics "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        mock "github.com/stretchr/testify/mock"

        storage "github.com/maynagashev/go-metrics/internal/server/storage"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
        mock.Mock
}

// Close provides a mock function with given fields:
func (_m *Repository) Close() error <span class="cov8" title="1">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Close")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Count provides a mock function with given fields:
func (_m *Repository) Count() int <span class="cov8" title="1">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Count")</span>
        }

        <span class="cov8" title="1">var r0 int
        if rf, ok := ret.Get(0).(func() int); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetCounter provides a mock function with given fields: name
func (_m *Repository) GetCounter(name string) (storage.Counter, bool) <span class="cov8" title="1">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCounter")</span>
        }

        <span class="cov8" title="1">var r0 storage.Counter
        var r1 bool
        if rf, ok := ret.Get(0).(func(string) (storage.Counter, bool)); ok </span><span class="cov0" title="0">{
                return rf(name)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) storage.Counter); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(storage.Counter)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) bool); ok </span><span class="cov0" title="0">{
                r1 = rf(name)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Get(1).(bool)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetGauge provides a mock function with given fields: name
func (_m *Repository) GetGauge(name string) (storage.Gauge, bool) <span class="cov8" title="1">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetGauge")</span>
        }

        <span class="cov8" title="1">var r0 storage.Gauge
        var r1 bool
        if rf, ok := ret.Get(0).(func(string) (storage.Gauge, bool)); ok </span><span class="cov0" title="0">{
                return rf(name)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) storage.Gauge); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(storage.Gauge)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) bool); ok </span><span class="cov0" title="0">{
                r1 = rf(name)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Get(1).(bool)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetMetric provides a mock function with given fields: mType, name
func (_m *Repository) GetMetric(mType metrics.MetricType, name string) (metrics.Metric, bool) <span class="cov8" title="1">{
        ret := _m.Called(mType, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMetric")</span>
        }

        <span class="cov8" title="1">var r0 metrics.Metric
        var r1 bool
        if rf, ok := ret.Get(0).(func(metrics.MetricType, string) (metrics.Metric, bool)); ok </span><span class="cov0" title="0">{
                return rf(mType, name)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(metrics.MetricType, string) metrics.Metric); ok </span><span class="cov0" title="0">{
                r0 = rf(mType, name)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(metrics.Metric)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(metrics.MetricType, string) bool); ok </span><span class="cov0" title="0">{
                r1 = rf(mType, name)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Get(1).(bool)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetMetrics provides a mock function with given fields:
func (_m *Repository) GetMetrics() []metrics.Metric <span class="cov8" title="1">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMetrics")</span>
        }

        <span class="cov8" title="1">var r0 []metrics.Metric
        if rf, ok := ret.Get(0).(func() []metrics.Metric); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]metrics.Metric)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// UpdateMetric provides a mock function with given fields: metric
func (_m *Repository) UpdateMetric(metric metrics.Metric) error <span class="cov8" title="1">{
        ret := _m.Called(metric)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateMetric")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(metrics.Metric) error); ok </span><span class="cov0" title="0">{
                r0 = rf(metric)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// UpdateMetrics provides a mock function with given fields: _a0
func (_m *Repository) UpdateMetrics(_a0 []metrics.Metric) error <span class="cov8" title="1">{
        ret := _m.Called(_a0)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateMetrics")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func([]metrics.Metric) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *Repository <span class="cov8" title="1">{
        mock := &amp;Repository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by mockery v2.43.1. DO NOT EDIT.

package mocks

import (
        context "context"

        metrics "github.com/maynagashev/go-metrics/internal/contracts/metrics"
        mock "github.com/stretchr/testify/mock"
)

// Storage is an autogenerated mock type for the Storage type
type Storage struct {
        mock.Mock
}

// GetMetrics provides a mock function with given fields: ctx
func (_m *Storage) GetMetrics(ctx context.Context) []metrics.Metric <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMetrics")</span>
        }

        <span class="cov8" title="1">var r0 []metrics.Metric
        if rf, ok := ret.Get(0).(func(context.Context) []metrics.Metric); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]metrics.Metric)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// NewStorage creates a new instance of Storage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *Storage <span class="cov8" title="1">{
        mock := &amp;Storage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package crypto предоставляет функции для асимметричного шифрования и расшифровки.
// Он использует RSA шифрование для безопасной связи между агентом и сервером.
package crypto

import (
        "bytes"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/binary"
        "encoding/pem"
        "errors"
        "fmt"
        "math/big"
        "net"
        "os"
        "time"
)

const (
        // RSAOAEPPadding - количество байт, используемых для паддинга в RSA-OAEP.
        RSAOAEPPadding = 2

        // CertValidityYears - срок действия сертификата в годах.
        CertValidityYears = 10

        // LoopbackIPv4First - первый октет для 127.0.0.1.
        LoopbackIPv4First = 127

        // LoopbackIPv4Second - второй октет для 127.0.0.1.
        LoopbackIPv4Second = 0

        // LoopbackIPv4Third - третий октет для 127.0.0.1.
        LoopbackIPv4Third = 0

        // LoopbackIPv4Fourth - четвертый октет для 127.0.0.1.
        LoopbackIPv4Fourth = 1
)

// LoadPublicKey загружает открытый ключ RSA из файла.
func LoadPublicKey(path string) (*rsa.PublicKey, error) <span class="cov8" title="1">{
        keyData, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("не удалось прочитать файл открытого ключа: %w", err)
        }</span>

        <span class="cov8" title="1">block, _ := pem.Decode(keyData)
        if block == nil </span><span class="cov0" title="0">{
                return nil, errors.New("не удалось декодировать PEM блок")
        }</span>

        // Обрабатываем оба формата: сертификат и открытый ключ
        <span class="cov8" title="1">switch block.Type </span>{
        case "CERTIFICATE":<span class="cov8" title="1">
                cert, certErr := x509.ParseCertificate(block.Bytes)
                if certErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("не удалось разобрать сертификат: %w", certErr)
                }</span>

                <span class="cov8" title="1">rsaPub, ok := cert.PublicKey.(*rsa.PublicKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("сертификат не содержит открытый ключ RSA")
                }</span>

                <span class="cov8" title="1">return rsaPub, nil</span>

        case "PUBLIC KEY":<span class="cov0" title="0">
                pub, pubErr := x509.ParsePKIXPublicKey(block.Bytes)
                if pubErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("не удалось разобрать открытый ключ: %w", pubErr)
                }</span>

                <span class="cov0" title="0">rsaPub, ok := pub.(*rsa.PublicKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("ключ не является открытым ключом RSA")
                }</span>

                <span class="cov0" title="0">return rsaPub, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("неподдерживаемый тип ключа: %s", block.Type)</span>
        }
}

// LoadPrivateKey загружает закрытый ключ RSA из файла.
func LoadPrivateKey(path string) (*rsa.PrivateKey, error) <span class="cov8" title="1">{
        keyData, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("не удалось прочитать файл закрытого ключа: %w", err)
        }</span>

        <span class="cov8" title="1">block, _ := pem.Decode(keyData)
        if block == nil </span><span class="cov0" title="0">{
                return nil, errors.New("не удалось декодировать PEM блок")
        }</span>

        // Обрабатываем различные форматы закрытого ключа
        <span class="cov8" title="1">switch block.Type </span>{
        case "RSA PRIVATE KEY":<span class="cov8" title="1">
                // Формат PKCS#1
                return x509.ParsePKCS1PrivateKey(block.Bytes)</span>

        case "PRIVATE KEY":<span class="cov0" title="0">
                // Формат PKCS#8
                priv, privErr := x509.ParsePKCS8PrivateKey(block.Bytes)
                if privErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("не удалось разобрать закрытый ключ PKCS#8: %w", privErr)
                }</span>

                <span class="cov0" title="0">rsaPriv, ok := priv.(*rsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("ключ не является закрытым ключом RSA")
                }</span>

                <span class="cov0" title="0">return rsaPriv, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("неподдерживаемый тип ключа: %s", block.Type)</span>
        }
}

// Encrypt шифрует данные с использованием RSA-OAEP с SHA-256.
// Примечание: RSA может шифровать только небольшие объемы данных.
// Для ключа 2048 бит максимальный размер данных составляет около 190 байт.
func Encrypt(publicKey *rsa.PublicKey, data []byte) ([]byte, error) <span class="cov8" title="1">{
        return rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, data, nil)
}</span>

// Decrypt расшифровывает данные с использованием RSA-OAEP с SHA-256.
func Decrypt(privateKey *rsa.PrivateKey, ciphertext []byte) ([]byte, error) <span class="cov8" title="1">{
        return rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, nil)
}</span>

// Формат: [количество частей (4 байта)][размер части 1 (4 байта)][часть 1]...[размер части N (4 байта)][часть N].
func EncryptLargeData(publicKey *rsa.PublicKey, data []byte) ([]byte, error) <span class="cov8" title="1">{
        // Определяем максимальный размер данных, которые можно зашифровать за один раз
        // Для RSA-OAEP с SHA-256 это (размер ключа в байтах) - 2 * (размер хеша в байтах) - 2
        maxChunkSize := (publicKey.Size() - 2*sha256.Size - RSAOAEPPadding)

        // Разбиваем данные на части
        var chunks [][]byte
        for i := 0; i &lt; len(data); i += maxChunkSize </span><span class="cov8" title="1">{
                end := i + maxChunkSize
                if end &gt; len(data) </span><span class="cov8" title="1">{
                        end = len(data)
                }</span>
                <span class="cov8" title="1">chunks = append(chunks, data[i:end])</span>
        }

        // Шифруем каждую часть
        <span class="cov8" title="1">encryptedChunks := make([][]byte, 0, len(chunks))
        for _, chunk := range chunks </span><span class="cov8" title="1">{
                encryptedChunk, err := Encrypt(publicKey, chunk)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при шифровании части данных: %w", err)
                }</span>
                <span class="cov8" title="1">encryptedChunks = append(encryptedChunks, encryptedChunk)</span>
        }

        // Формируем результат
        <span class="cov8" title="1">var result bytes.Buffer

        // Проверяем, что количество частей не превышает максимальное значение uint32
        if len(encryptedChunks) &gt; int(^uint32(0)) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "слишком много частей данных для шифрования: %d",
                        len(encryptedChunks),
                )
        }</span>

        // Записываем количество частей (4 байта)
        // #nosec G115 - мы проверили выше, что len(encryptedChunks) не превышает максимальное значение uint32
        <span class="cov8" title="1">numChunks := uint32(len(encryptedChunks))
        if err := binary.Write(&amp;result, binary.BigEndian, numChunks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при записи количества частей: %w", err)
        }</span>

        // Записываем каждую зашифрованную часть с её размером
        <span class="cov8" title="1">for _, chunk := range encryptedChunks </span><span class="cov8" title="1">{
                // Проверяем, что размер части не превышает максимальное значение uint32
                if len(chunk) &gt; int(^uint32(0)) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("размер части данных слишком велик: %d", len(chunk))
                }</span>

                // Записываем размер части (4 байта)
                // #nosec G115 - мы проверили выше, что len(chunk) не превышает максимальное значение uint32
                <span class="cov8" title="1">chunkSize := uint32(len(chunk))
                if err := binary.Write(&amp;result, binary.BigEndian, chunkSize); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при записи размера части: %w", err)
                }</span>

                // Записываем саму часть
                <span class="cov8" title="1">if _, err := result.Write(chunk); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при записи части: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return result.Bytes(), nil</span>
}

// DecryptLargeData расшифровывает данные, которые были зашифрованы с помощью EncryptLargeData.
func DecryptLargeData(privateKey *rsa.PrivateKey, data []byte) ([]byte, error) <span class="cov8" title="1">{
        buffer := bytes.NewReader(data)

        // Читаем количество частей
        var numChunks uint32
        if err := binary.Read(buffer, binary.BigEndian, &amp;numChunks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при чтении количества частей: %w", err)
        }</span>

        // Читаем и расшифровываем каждую часть
        <span class="cov8" title="1">var result bytes.Buffer
        for i := range numChunks </span><span class="cov8" title="1">{
                // Читаем размер части
                var chunkSize uint32
                if err := binary.Read(buffer, binary.BigEndian, &amp;chunkSize); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при чтении размера части %d: %w", i, err)
                }</span>

                // Читаем саму часть
                <span class="cov8" title="1">chunk := make([]byte, chunkSize)
                if _, err := buffer.Read(chunk); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при чтении части %d: %w", i, err)
                }</span>

                // Расшифровываем часть
                <span class="cov8" title="1">decryptedChunk, err := Decrypt(privateKey, chunk)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при расшифровке части %d: %w", i, err)
                }</span>

                // Добавляем расшифрованную часть к результату
                <span class="cov8" title="1">if _, writeErr := result.Write(decryptedChunk); writeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при записи расшифрованной части %d: %w", i, writeErr)
                }</span>
        }

        <span class="cov8" title="1">return result.Bytes(), nil</span>
}

// GenerateKeyPair генерирует новую пару ключей RSA и сохраняет их в файлы.
// Также генерирует сертификат X.509 для открытого ключа.
func GenerateKeyPair(privateKeyPath, publicKeyPath string, bits int) error <span class="cov8" title="1">{
        // Создаем шаблон сертификата
        cert := &amp;x509.Certificate{
                SerialNumber: big.NewInt(time.Now().Unix()),
                Subject: pkix.Name{
                        Organization: []string{"go-metrics"},
                        Country:      []string{"RU"},
                },
                IPAddresses: []net.IP{
                        net.IPv4(LoopbackIPv4First, LoopbackIPv4Second, LoopbackIPv4Third, LoopbackIPv4Fourth),
                        net.IPv6loopback,
                },
                NotBefore:    time.Now(),
                NotAfter:     time.Now().AddDate(CertValidityYears, 0, 0), // Действителен 10 лет
                SubjectKeyId: []byte{1, 2, 3, 4, 6},
                ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
                KeyUsage:     x509.KeyUsageDigitalSignature,
        }

        // Генерируем новую пару ключей RSA
        privateKey, err := rsa.GenerateKey(rand.Reader, bits)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось сгенерировать пару ключей RSA: %w", err)
        }</span>

        // Создаем сертификат
        <span class="cov8" title="1">certBytes, err := x509.CreateCertificate(
                rand.Reader,
                cert,
                cert,
                &amp;privateKey.PublicKey,
                privateKey,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось создать сертификат: %w", err)
        }</span>

        // Сохраняем закрытый ключ в файл (формат PKCS#1)
        <span class="cov8" title="1">privateKeyFile, err := os.Create(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось создать файл закрытого ключа: %w", err)
        }</span>
        <span class="cov8" title="1">defer privateKeyFile.Close()

        privateKeyPEM := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        }

        if encodeErr := pem.Encode(privateKeyFile, privateKeyPEM); encodeErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось записать закрытый ключ в файл: %w", encodeErr)
        }</span>

        // Сохраняем открытый ключ в файл
        <span class="cov8" title="1">publicKeyFile, err := os.Create(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось создать файл открытого ключа: %w", err)
        }</span>
        <span class="cov8" title="1">defer publicKeyFile.Close()

        // Используем сертификат как открытый ключ
        publicKeyPEM := &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: certBytes,
        }

        if encodeErr := pem.Encode(publicKeyFile, publicKeyPEM); encodeErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось записать открытый ключ в файл: %w", encodeErr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package crypto предоставляет middleware для обработки зашифрованных запросов.
package crypto

import (
        "bytes"
        "context"
        "io"
        "net/http"

        "go.uber.org/zap"

        "github.com/maynagashev/go-metrics/internal/server/app"
        "github.com/maynagashev/go-metrics/pkg/crypto"
        "github.com/maynagashev/go-metrics/pkg/sign"
)

// Middleware представляет middleware для обработки шифрования и подписи запросов.
type Middleware struct {
        log              *zap.Logger
        config           *app.Config
        processedBodyKey ContextKey
}

// ContextKey - тип для ключей контекста.
type ContextKey struct {
        name string
}

// String возвращает строковое представление ключа контекста.
func (k ContextKey) String() string <span class="cov0" title="0">{
        return "crypto middleware context key: " + k.name
}</span>

// New создает новый middleware для обработки шифрования и подписи запросов.
func New(config *app.Config, log *zap.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        m := &amp;Middleware{
                log:              log,
                config:           config,
                processedBodyKey: ContextKey{"processed_body"},
        }

        return m.Handler
}</span>

// Handler обрабатывает запрос, выполняя дешифрование и проверку подписи при необходимости.
func (m *Middleware) Handler(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Проверяем, есть ли тело запроса
                if r.Body == nil </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Читаем тело запроса
                <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        m.log.Error("failed to read request body", zap.Error(err))
                        http.Error(w, "Failed to read request body", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">defer r.Body.Close()

                // Обрабатываем шифрование и подпись
                processedBody, ok := m.processRequestBody(w, r, body)
                if !ok </span><span class="cov8" title="1">{
                        return // Ошибка уже обработана в processRequestBody
                }</span>

                // Заменяем тело запроса обработанными данными
                <span class="cov8" title="1">r.Body = io.NopCloser(bytes.NewReader(processedBody))

                // Сохраняем обработанное тело в контексте для возможного использования в обработчиках
                ctx := r.Context()
                ctx = context.WithValue(ctx, m.processedBodyKey, processedBody)
                r = r.WithContext(ctx)

                // Создаем обертку для ResponseWriter, чтобы добавить подпись к ответу
                if m.config.IsRequestSigningEnabled() </span><span class="cov8" title="1">{
                        w = &amp;signedResponseWriter{
                                ResponseWriter: w,
                                privateKey:     m.config.PrivateKey,
                        }
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// Возвращает обработанное тело и флаг успешности операции.
func (m *Middleware) processRequestBody(
        w http.ResponseWriter,
        r *http.Request,
        body []byte,
) ([]byte, bool) <span class="cov8" title="1">{
        // Обрабатываем шифрование
        processedBody, ok := m.handleEncryption(w, r, body)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Проверяем подпись запроса
        <span class="cov8" title="1">if isValid := m.verifyRequestSignature(w, r, processedBody); !isValid </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">return processedBody, true</span>
}

// Возвращает обработанное тело и флаг успешности операции.
func (m *Middleware) handleEncryption(
        w http.ResponseWriter,
        r *http.Request,
        body []byte,
) ([]byte, bool) <span class="cov8" title="1">{
        if r.Header.Get("Content-Encrypted") != "true" </span><span class="cov8" title="1">{
                return body, true
        }</span>

        <span class="cov0" title="0">if !m.config.IsEncryptionEnabled() </span><span class="cov0" title="0">{
                m.log.Error("received encrypted data but server has no private key configured")
                http.Error(w, "Server is not configured for encryption", http.StatusBadRequest)
                return nil, false
        }</span>

        <span class="cov0" title="0">m.log.Debug("decrypting request body")
        decrypted, err := crypto.DecryptLargeData(m.config.PrivateRSAKey, body)
        if err != nil </span><span class="cov0" title="0">{
                m.log.Error("failed to decrypt data", zap.Error(err))
                http.Error(w, "Failed to decrypt request body", http.StatusBadRequest)
                return nil, false
        }</span>

        <span class="cov0" title="0">return decrypted, true</span>
}

// Возвращает флаг успешности операции.
func (m *Middleware) verifyRequestSignature(
        w http.ResponseWriter,
        r *http.Request,
        body []byte,
) bool <span class="cov8" title="1">{
        if !m.config.IsRequestSigningEnabled() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">hashFromRequest := r.Header.Get(sign.HeaderKey)
        if hashFromRequest == "" </span><span class="cov8" title="1">{
                return true // Нет подписи, пропускаем проверку
        }</span>

        <span class="cov8" title="1">hash, vErr := sign.VerifyHMACSHA256(body, m.config.PrivateKey, hashFromRequest)
        m.log.Debug(
                "validateRequest =&gt; sign.VerifyHMACSHA256",
                zap.String("hash_from_request", hashFromRequest),
                zap.Error(vErr),
                zap.String("calc_hash", hash),
        )
        if vErr != nil </span><span class="cov8" title="1">{
                m.log.Error("failed to verify request signature", zap.Error(vErr))
                http.Error(w, "Invalid request signature", http.StatusBadRequest)
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// signedResponseWriter - обертка для http.ResponseWriter, которая добавляет подпись к ответу.
type signedResponseWriter struct {
        http.ResponseWriter
        privateKey string
}

// Write перехватывает запись в ResponseWriter и добавляет подпись.
func (w *signedResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        // Вычисляем подпись
        hash := sign.ComputeHMACSHA256(b, w.privateKey)

        // Добавляем подпись в заголовок
        w.Header().Set(sign.HeaderKey, hash)

        // Записываем данные в оригинальный ResponseWriter
        return w.ResponseWriter.Write(b)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package gzip предоставляет функции для сжатия данных методом gzip.
package gzip

import (
        "bytes"
        "compress/gzip"
        "fmt"
)

// Compress сжимает данные методом gzip.
// Использует максимальный уровень сжатия.
// Возвращает сжатые данные и ошибку в случае неудачи.
func Compress(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var b bytes.Buffer
        // создаём переменную w — в неё будут записываться входящие данные,
        // которые будут сжиматься и сохраняться в bytes.Buffer
        w, err := gzip.NewWriterLevel(&amp;b, gzip.BestCompression)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed init compress writer: %w", err)
        }</span>

        // запись данных
        <span class="cov8" title="1">_, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed write data to compress temporary buffer: %w", err)
        }</span>

        // обязательно нужно вызвать метод Close() — в противном случае часть данных
        // может не записаться в буфер b; если нужно выгрузить все упакованные данные
        // в какой-то момент сжатия, используйте метод Flush()
        <span class="cov8" title="1">err = w.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed compress data: %w", err)
        }</span>
        // буфер b содержит сжатые данные
        <span class="cov8" title="1">return b.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package random предоставляет функции для генерации случайных чисел.
// Использует криптографически стойкий генератор случайных чисел.
package random

import (
        "crypto/rand"
        "math"
        "math/big"
)

// GenerateRandomFloat64 генерирует случайное число типа float64 в диапазоне от 0 до 1.
func GenerateRandomFloat64() float64 <span class="cov8" title="1">{
        // Генерация случайного int64.
        randomInt, err := rand.Int(rand.Reader, big.NewInt(math.MaxInt64))
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Преобразование int64 в float64 в диапазоне от 0 до 1.
        <span class="cov8" title="1">randomFloat := float64(randomInt.Int64()) / float64(math.MaxInt64)

        return randomFloat</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package response предоставляет функции для формирования стандартизированных HTTP-ответов.
// Поддерживает ответы в формате JSON с информацией о статусе и сообщением.
package response

import (
        "encoding/json"
        "fmt"
        "net/http"
)

type Response struct {
        Status  string `json:"status"`
        Message string `json:"message,omitempty"`
        Error   string `json:"error,omitempty"`
}

const (
        StatusOK    = "OK"
        StatusError = "Error"
)

func OK(w http.ResponseWriter, msg string) <span class="cov8" title="1">{
        resp := Response{
                Status:  StatusOK,
                Message: msg,
        }
        writeResponse(w, resp, http.StatusOK)
}</span>

func Error(w http.ResponseWriter, err error, statusCode int) <span class="cov8" title="1">{
        resp := Response{
                Status: StatusError,
                Error:  err.Error(),
        }
        writeResponse(w, resp, statusCode)
}</span>

// Стандартные ответы в json формате.
func writeResponse(w http.ResponseWriter, resp Response, statusCode int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        // Кодируем структуру в json.
        encoded, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Отправляем ответ.
        <span class="cov8" title="1">_, err = fmt.Fprint(w, string(encoded))
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package sign предоставляет функции для создания и проверки цифровых подписей.
// Реализует подпись данных с использованием алгоритма HMAC-SHA256.
package sign

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "log/slog"
)

const HeaderKey = "HashSHA256"

// ComputeHMACSHA256 вычисляет хеш SHA256 от данных с использованием ключа.
func ComputeHMACSHA256(data []byte, key string) string <span class="cov8" title="1">{
        h := hmac.New(sha256.New, []byte(key))
        if _, err := h.Write(data); err != nil </span><span class="cov0" title="0">{
                // Log the error or handle it appropriately
                // Since we know this won't fail, we can just panic or log a message
                slog.Error("unexpected error writing to hash", "error", err)
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(h.Sum(nil))</span>
}

// VerifyHMACSHA256 проверяет, что хеш SHA256 от данных с использованием ключа совпадает с ожидаемым значением.
func VerifyHMACSHA256(data []byte, key string, expectedMAC string) (string, error) <span class="cov8" title="1">{
        // Если хэш не задан, то и не проверяем.
        // Тесты предполагают что с пустым хэшем его не следует проверять, даже если указан приватный ключ -k при старте.
        // См. обсуждение в чате: https://app.pachca.com/chats/8850763?message=245816301
        if expectedMAC == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">mac := ComputeHMACSHA256(data, key)

        if !hmac.Equal([]byte(mac), []byte(expectedMAC)) </span><span class="cov8" title="1">{
                return mac, errors.New("invalid hash in request header")
        }</span>

        <span class="cov8" title="1">return mac, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
